! Select the version of the code to be tested:
!#define test48 4
#define test48 8

!!!prog Test_Vertical_Interpolation -program that automates testing of ez_interpv
program Test_Vertical_Interpolation
!
!AUTHOR
!     J.W. Blezius OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - formalized from existing non-automatic test
!    ?    Blezius J.W. FEB 2010 - improve test values for normalized hybrid
!                               - add test for (new) un-normalized hybrid
!                               - remove test for the defunct pre-X interface
!
!OBJECT
!        To test the ez_interpv package, with its ViIfc interface.
!
!ARGUMENTS
!
!NOTES
!
!!
  implicit none
  include "ViConstants_f90.h"
  include "VertInterp_f90.h"



  external m_slStateValueStub,     m_slFluxGradientStub
  external m_slStateValueWindStub, m_slFluxGradientWindStub

  real, parameter :: r_HMIN = 30.
  integer, parameter :: n_PTS_INIT=4
  integer, parameter :: n_PTS_TARGET=5
  integer, parameter :: n_NI=2, &  ! sin and tan
                        n_NJ=1
  integer :: i, j, k
  integer :: error

  character(60) :: s_title, s_interpType, s_extrapType
  logical :: l_pass
  integer :: n_gridType
  real, dimension(n_PTS_INIT) :: r_levelsInit, r_temp1
  real, dimension(n_PTS_TARGET) :: r_levelsTarget
  real, dimension(n_NI,n_NJ,n_PTS_INIT) :: r_stateIncreasing, r_stateDecreasing,&
                                           r_stateIn, &
                                           r_derivIncreasing, r_derivDecreasing,&
                                           r_derivIn, r_y_derivIn, &
                                           r_zSrc, r_temp3, r_y_stateIn
  real, dimension(n_NI,n_NJ,n_PTS_TARGET) :: r_stateAnswer, r_derivAnswer, &
                                             r_zDest, &
                                             r_y_stateAnswer, r_y_derivAnswer

  real, parameter :: r_EXTRAP_GUIDE_DOWN=0.4, &
                     r_EXTRAP_GUIDE_UP=-0.5

  real, parameter :: r_PTOP_INIT=10., &
                     r_PREF_INIT=800., &
                     r_RCOEFF_INIT=1., &

                     r_PTOP_TARGET=10., &
                     r_PREF_TARGET=800., &
                     r_RCOEFF_TARGET=1.

  real, parameter :: r_factn = 1.2

  real, dimension(n_NI, n_NJ), parameter :: r_PSURF = 100000.
  real, dimension(n_NI, n_NJ), parameter :: r_PTOP = 10.

                                        ! angle, in radians, INCREASING
  real, dimension(n_PTS_INIT), parameter :: r_LEVELS_INCREASING= &
                                                       (/0.64, 1.25, 2.44, 2.97/)
                                        ! angle, in radians, DECREASING
  real, dimension(n_PTS_INIT), parameter :: r_LEVELS_DECREASING= &
                                                       (/2.97, 2.44, 1.25, 0.64/)
                                        ! angle, in radians, standard values
  real, dimension(n_PTS_TARGET), parameter :: r_LEVELS_TARGET_STD= &
                                                   (/1.13, 2.62, 2.79, 0.5, 3.1/)

  ! The next four parameters are used only for surface extrapolation
                                        ! roughness length
  real, dimension(n_NI, n_NJ) :: r_z0
                                        ! inverse Monin-Obukhov length
  real, dimension(n_NI, n_NJ) :: r_ilmo
                                        ! height of the boundary layer
  real, dimension(n_NI, n_NJ) :: r_hBound
                                        ! latitude (used only for the wind)
  real, dimension(n_NI, n_NJ) :: r_lat



  ! ascending
  r_stateIncreasing(1,1,1) = 0.5971954   ! sin 0.64
  r_stateIncreasing(1,1,2) = 0.9489846   ! sin 1.25
  r_stateIncreasing(1,1,3) = 0.6454      ! sin 2.44
  r_stateIncreasing(1,1,4) = 0.1708      ! sin 2.97

  r_derivIncreasing(1,1,1) = 0.8020958   ! cos 0.64
  r_derivIncreasing(1,1,2) = 0.3153224   ! cos 1.25
  r_derivIncreasing(1,1,3) =-0.7638      ! cos 2.44
  r_derivIncreasing(1,1,4) =-0.9853      ! cos 2.97


  r_stateIncreasing(2,1,1) = 0.744544    ! tan 0.64
  r_stateIncreasing(2,1,2) = 3.009570    ! tan 1.25
  r_stateIncreasing(2,1,3) =-0.8450      ! tan 2.44
  r_stateIncreasing(2,1,4) =-0.1733      ! tan 2.97

  r_derivIncreasing(2,1,1) = 1.554346    ! 1/cos2 0.64
  r_derivIncreasing(2,1,2) = 10.057510   ! 1/cos2 1.25
  r_derivIncreasing(2,1,3) = 1.7140      ! 1/cos2 2.44
  r_derivIncreasing(2,1,4) = 1.03003     ! 1/cos2 2.97

  ! descending
  r_stateDecreasing(1,1,4) = 0.5971954   ! sin 0.64
  r_stateDecreasing(1,1,3) = 0.9489846   ! sin 1.25
  r_stateDecreasing(1,1,2) = 0.6454      ! sin 2.44
  r_stateDecreasing(1,1,1) = 0.1708      ! sin 2.97

  r_derivDecreasing(1,1,4) = 0.8020958   ! cos 0.64
  r_derivDecreasing(1,1,3) = 0.3153224   ! cos 1.25
  r_derivDecreasing(1,1,2) =-0.7638      ! cos 2.44
  r_derivDecreasing(1,1,1) =-0.9853      ! cos 2.97


  r_stateDecreasing(2,1,4) = 0.744544    ! tan 0.64
  r_stateDecreasing(2,1,3) = 3.009570    ! tan 1.25
  r_stateDecreasing(2,1,2) =-0.8450      ! tan 2.44
  r_stateDecreasing(2,1,1) =-0.1733      ! tan 2.97

  r_derivDecreasing(2,1,4) = 1.554346    ! 1/cos2 0.64
  r_derivDecreasing(2,1,3) = 10.057510   ! 1/cos2 1.25
  r_derivDecreasing(2,1,2) = 1.7140      ! 1/cos2 2.44
  r_derivDecreasing(2,1,1) = 1.03003     ! 1/cos2 2.97


  !
  ! START THE SERIES OF TESTS
  !
  l_pass = .true.





  !
  ! FIRST TEST
  ! FIRST TEST
  !
  s_title = "TEST 1:  normalized hybrid; cubic derivs; clamped; ascending"

!  n_gridType = N_GRID_TYPE_SIGMA
!  n_gridType = N_GRID_TYPE_PRESSURE
!  n_gridType = N_GRID_TYPE_GENERIC
  n_gridType = N_GRID_TYPE_HYBRID
!  n_gridType = N_GRID_TYPE_ETA
!  n_gridType = N_GRID_TYPE_HYBRID_NOTNORM
!  n_gridType = N_GRID_TYPE_STAGGERED

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/1.0035486, 0.9274864, 0.2265282, 0.1708000, 1.0035486/)
  r_stateAnswer(2,1,:) =(/4.2508826, 1.2185184,-0.2344213,-0.1733000, 4.2508826/)

  r_derivAnswer(1,1,:) =(/0.0977639,-0.3641385,-1.1846591,-0.9853000, 0.0977639/)
  r_derivAnswer(2,1,:) =(/0.0247765,-7.5026307, 1.3508555, 1.0300300, 0.0247765/)

  !
  ! MAKE THE DATA REASONABLE FOR THE HYBRID GRID TYPE
  !
  ! convert the levels to reasonable hybrid values
  do i=1,n_PTS_INIT
    r_levelsInit(i) = r_levelsInit(i) / 3.2
  end do

  ! convert the levels to reasonable hybrid values
  do i=n_PTS_TARGET,2,-1
    r_levelsTarget(i) = r_levelsTarget(i-1) / 3.2
  end do
  r_levelsTarget(1) = r_levelsInit(1)
  r_levelsTarget(5) = r_levelsTarget(1) ! ensure that nothing is below 'ground'


! NOTE:  modifying the initial pref and rcoeff
  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT/2., r_RCOEFF_INIT*2., &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! SECOND TEST
  ! SECOND TEST
  !
  s_title = "TEST 2:  generic; cubic derivs; clamped; ascending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.9042932, 0.4981775, 0.3443519, 0.5971954, 0.1708000/)
  r_stateAnswer(2,1,:) =(/2.0318060,-0.5722344,-0.3647639, 0.7445440,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.4281423,-0.8671802,-0.9382274, 0.8020958,-0.9853000/)
  r_derivAnswer(2,1,:) =(/6.4005327, 1.3408751, 1.1214883, 1.5543460, 1.0300300/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! THIRD TEST
  ! THIRD TEST
  !
  s_title = "TEST 3:  generic; cubic Lagrange; clamped; ascending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING

  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubiclagrange'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.9099222, 0.5043430, 0.3516999, 0.5971954, 0.1708000/)
  r_stateAnswer(2,1,:) =(/3.0054035,-1.0220673,-0.8364134, 0.7445440,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! FOURTH TEST
  ! FOURTH TEST
  !
  s_title = "TEST 4:  generic; nearest neighbour; lapse rate; ascending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'nearestneighbour'
  s_extrapType = 'lapserate'

  r_stateAnswer(1,1,:) =(/0.9489846, 0.6454000, 0.1708000, 0.5411954, 0.1058001/)
  r_stateAnswer(2,1,:) =(/3.0095699,-0.8450000,-0.1733000, 0.6885440,-0.2382999/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! FIFTH TEST
  ! FIFTH TEST
  !
  s_title = "TEST 5:  generic; linear; clamped; ascending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'linear'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.8797802, 0.4842152, 0.3319850, 0.5971954, 0.1708000/)
  r_stateAnswer(2,1,:) =(/2.5639911,-0.6168757,-0.4014246, 0.7445440,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! SIXTH TEST
  ! SIXTH TEST
  !
  s_title = "TEST 6:  generic; cubic derivs; clamped; descending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_DECREASING
  r_stateIn      = r_stateDecreasing
  r_derivIn      = r_derivDecreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.9042932, 0.4981775, 0.3443519, 0.5971954, 0.1708000/)
  r_stateAnswer(2,1,:) =(/2.0318060,-0.5722344,-0.3647639, 0.7445440,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.4281423,-0.8671802,-0.9382274, 0.8020958,-0.9853000/)
  r_derivAnswer(2,1,:) =(/6.4005327, 1.3408751, 1.1214883, 1.5543460, 1.0300300/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! SEVENTH TEST
  ! SEVENTH TEST
  !
  s_title = "TEST 7:  generic; no interpolation; surface; special values"

  n_gridType = N_GRID_TYPE_GENERIC

  r_derivIn      = r_derivDecreasing    ! unused


  ! Set the source and destionation levels
  ! Set also the state values (simulate temperature or humidity values)
                                        ! The r_levelsInit determine only to
                                        ! which points the extrapolation will be
                                        ! applied
  r_levelsInit(1) = 12000
  r_levelsInit(2) = 15000
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.             ! at the surface
      r_stateIn(i,j,2) = 100.           ! lowest source level above the surface
    end do
  end do
  do k=3,n_PTS_INIT
    r_levelsInit(k) = 16000 + k
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + k
      end do
    end do
  end do
  do k=1,n_PTS_TARGET
    r_levelsTarget(k) = 13000 + k       ! Set them to extrapolate all points
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.
      r_zSrc (i,j,2) = 100.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=5*(k-1.)
      end do

      r_z0(i,j)=1.0
      r_hBound(i,j)=300.
                                        ! Perform a quality control on hBound
      r_hBound(i,j)=max(r_HMIN, &
                        r_hBound(i,j), &
                        (r_stateIn(i,j,2)+2*r_z0(i,j))*r_factn &
                       )
      r_ilmo(i,j)=-0.01+i*0.01
      r_lat(i,j)=0 !unused
    end do
  end do

  s_interpType = 'cubiclagrange'
  s_extrapType = 'surface'

  r_stateAnswer(1,1,:) =(/0.0000000,38.8236809,51.9573746,60.0761986,65.9684296/)
  r_stateAnswer(2,1,:) =(/0.0000000,23.9199448,33.9498825,41.2683907,47.3830299/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )





  !
  ! EIGHTH TEST
  ! EIGHTH TEST
  !
  s_title = "TEST 8:  generic; cubic derivs; clamped; ascending"
            ! Just to set the ground for the following test

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_stateIn(i,j,2) = 100.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + 10.*k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.               !r_zSrc, r_zDest ignored by cubiclagrange
      r_zSrc (i,j,2) = 100.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=5*(k-1.)
      end do

      r_z0(i,j)=1.0
      r_hBound(i,j)=300.
                                        ! Perform a quality control on hBound
      r_hBound(i,j)=max(r_HMIN, &
                        r_hBound(i,j), &
                        (r_stateIn(i,j,2)+2*r_z0(i,j))*r_factn &
                       )
      r_ilmo(i,j)=-0.01+i*0.01
      r_lat(i,j)=0 !unused
    end do
  end do

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/39.0633202, 89.9036026,137.3696594,100.1704407,140.00/)
  r_stateAnswer(2,1,:) =(/38.5082512, 89.1635284,137.3114929,100.6124878,140.00/)

  r_derivAnswer(1,1,:) =(/240.3235626,155.3128662,25.6568794, 6.4125767,-0.9853/)
  r_derivAnswer(2,1,:) =(/237.2080841,158.3114777,24.8061295,14.3739252,1.03003/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )





  !
  ! NINTH TEST
  ! NINTH TEST
  !
  s_title = "TEST 9:  generic; cubic derivs; surface; ascending"
            ! This is the same as the previous test, except that surface
            ! extrapolation has been chosen.  Compared to the results of the
            ! previous test, surface extrapolation should apply only to the
            ! surface layer [r_levelsTarget(1:2) should have the same result as
            ! test number SEVEN], and should adjust the interpolation in the next
            ! layer above that [r_levelsTarget(4)].  The derivative in the lowest
            ! interval and below is modified somewhat from test 8 since the
            ! surface extrapolation ensures a smooth derivative at the lowest
            ! level.

            ! N.B.:  The result from this calculation has been observed to be
            !        slightly different when compiled without optimization:
            !        derivOut(1,4)=13.3242283

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_stateIn(i,j,2) = 100.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + 10.*k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.               !r_zSrc, r_zDest ignored by cubiclagrange
      r_zSrc (i,j,2) = 100.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=5*(k-1.)
      end do

      r_z0(i,j)=1.0
      r_hBound(i,j)=300.
                                        ! Perform a quality control on hBound
      r_hBound(i,j)=max(r_HMIN, &
                        r_hBound(i,j), &
                        (r_stateIn(i,j,2)+2*r_z0(i,j))*r_factn &
                       )
      r_ilmo(i,j)=-0.01+i*0.01
      r_lat(i,j)=0 !unused
    end do
  end do

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'surface'

  r_stateAnswer(1,1,:) =(/0.0000000, 38.8236809,137.3696594,100.5492554,140.00/)
  r_stateAnswer(2,1,:) =(/0.0000000, 23.9199448,137.3114929,100.8274612,140.00/)

  r_derivAnswer(1,1,:) =(/237.7854919,158.0306396,25.6568794,13.3242273,-0.9853/)
  r_derivAnswer(2,1,:) =(/235.7677765,159.8537598,24.8061295,18.2961540,1.03003/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )





  !
  ! TENTH TEST
  ! TENTH TEST
  !
  s_title = "TEST 10:  generic; cubic Lagrange; surface; ascending"
            ! This is the same as the previous test, except that the
            ! interpolation has been changed to cubicLagrange.  In this case,
            ! surface extrapolation should apply to the surface layer as in the
            ! previous test [r_levelsTarget(1:2) should have the same result as
            ! test number NINE], and should adjust the interpolation in the next
            ! layer above that to use cubic with derivatives, albeit with a
            ! manufactured derivative [r_levelsTarget(4) should have a result
            ! that is different from that of test number NINE, also different
            ! from that of test number EIGHT, but similar to both of them],
            ! r_levelsTarget(5) will be the same because it is clamped
            ! extrapolation in both cases, but the rest [r_levelsTarget(3)]
            ! should be a little different.

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_stateIn(i,j,2) = 100.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + 10.*k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.               !r_zSrc, r_zDest ignored by cubiclagrange
      r_zSrc (i,j,2) = 100.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=5*(k-1.)
      end do

      r_z0(i,j)=1.0
      r_hBound(i,j)=300.
                                        ! Perform a quality control on hBound
      r_hBound(i,j)=max(r_HMIN, &
                        r_hBound(i,j), &
                        (r_stateIn(i,j,2)+2*r_z0(i,j))*r_factn &
                       )
      r_ilmo(i,j)=-0.01+i*0.01
      r_lat(i,j)=0 !unused
    end do
  end do

  s_interpType = 'cubiclagrange'
  s_extrapType = 'surface'

  r_stateAnswer(1,1,:) =(/0.0000000, 38.8236809,133.7804871,100.5033646,140.00/)
  r_stateAnswer(2,1,:) =(/0.0000000, 23.9199448,133.7804871,100.7865524,140.00/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )





  !
  ! ELEVENTH TEST
  ! ELEVENTH TEST
  !
  s_title = "TEST 11:  generic; surface; decreasing special values"
             ! This test is based on test seven, but with the input orders
             ! reversed such that it is decreasing.  The result should be the
             ! same as in test seven.

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit(1) = 0.
  r_levelsInit(2) = 100.
  r_derivIn      = r_derivDecreasing


  ! Set the source and destionation levels
  ! Set also the state values (simulate temperature or humidity values)
                                        ! The r_levelsInit determine only to
                                        ! which points the extrapolation will be
                                        ! applied
  r_levelsInit(1) = 12000
  r_levelsInit(2) = 15000
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.             ! at the surface
      r_stateIn(i,j,2) = 100.           ! lowest source level above the surface
    end do
  end do
  do k=3,n_PTS_INIT
    r_levelsInit(k) = 16000 + k
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + k
      end do
    end do
  end do
  do k=1,n_PTS_TARGET
    r_levelsTarget(k) = 13000 + k       ! Set them to extrapolate all points
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.
      r_zSrc (i,j,2) = 100.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=5*(k-1.)
      end do

      r_z0(i,j)=1.0
      r_hBound(i,j)=300.
                                        ! Perform a quality control on hBound
      r_hBound(i,j)=max(r_HMIN, &
                        r_hBound(i,j), &
                        (r_stateIn(i,j,2)+2*r_z0(i,j))*r_factn &
                       )
      r_ilmo(i,j)=-0.01+i*0.01
      r_lat(i,j)=0 !unused
    end do
  end do

  s_interpType = 'cubiclagrange'
  s_extrapType = 'surface'

  r_stateAnswer(1,1,:) =(/0.0000000,38.8236809,51.9573746,60.0761986,65.9684296/)
  r_stateAnswer(2,1,:) =(/0.0000000,23.9199448,33.9498825,41.2683907,47.3830299/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  ! Reverse the input order to decreasing
  r_temp3 = r_stateIn
  r_temp1 = r_levelsInit
  do k=1,n_PTS_INIT
    r_stateIn(:,:,k) = r_temp3(:,:,n_PTS_INIT+1-k)
    r_levelsInit(k) = r_temp1(n_PTS_INIT+1-k)
  end do

  r_temp3 = r_zSrc
  do k=1,n_PTS_INIT
    r_zSrc(:,:,k) = r_temp3(:,:,n_PTS_INIT+1-k)
  end do

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )





  !
  ! TWELFTH TEST
  ! TWELFTH TEST
  !
  s_title = "TEST 12:  generic; no interp'n; surface wind; special values"
            ! This is the same as test 7, but for the wind

  n_gridType = N_GRID_TYPE_GENERIC

                                        !determine only what will be extrapolated
                                        ! r_zSrc gives the levels used
  r_levelsInit(1) = 10000.
  r_levelsInit(2) = 160000.
  r_derivIn      = r_derivDecreasing


  ! Set the destionation levels
  ! Set also the state values (simulate wind values)
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 1000.          ! at the surface:  0 is assumed!
      r_y_stateIn(i,j,1) = 0.

      r_stateIn(i,j,2) = 10.            ! lowest source level above the surface
      r_y_stateIn(i,j,2) = 0.
    end do
  end do
  do k=3,n_PTS_INIT
    r_levelsInit(k) = 16000 + k
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 143. + k
      end do
    end do
  end do
  do k=1,n_PTS_TARGET
    r_levelsTarget(k) = 12. *  k        ! Set them to extrapolate all points
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.
      r_zSrc (i,j,2) = 80.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=12*k
      end do

      r_z0(i,j)=1.0
      r_ilmo(i,j)=-0.10+i*0.10
      r_hBound(i,j)=100./max(r_ilmo(i,j),1.e-9)
      r_lat(i,j)=1.0
    end do
  end do

  s_interpType = 'cubiclagrange'
  s_extrapType = 'surfacewind'

  r_stateAnswer(1,1,:) =(/5.8367934, 7.3248677, 8.2169971, 8.8562183, 9.3546963/)
  r_y_stateAnswer(1,1,:)=(/0.0000000,0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  r_stateAnswer(2,1,:) =(/3.6305752, 5.3461480, 6.6388068, 7.7134585, 8.6489334/)
  r_y_stateAnswer(2,1,:)=(/0.1767197,0.2142493, 0.2089990, 0.1765766, 0.1237315/)


  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_y_derivAnswer(1,1,:)=(/0.0000000,0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_y_derivAnswer(2,1,:)=(/0.0000000,0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat, &
                      r_y_stateIn, r_y_stateAnswer, r_y_derivIn,r_y_derivAnswer &
                     )





  !
  ! THIRTEENTH TEST
  ! THIRTEENTH TEST
  !
  s_title = "TEST 13:  generic; cubic derivs; clamped; ascending"
            ! Just to set the ground (y-component) for the following test.

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_stateIn(i,j,2) = 0.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 143. + k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.               !r_zSrc, r_zDest ignored by cubiclagrange
      r_zSrc (i,j,2) = 80.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=12.*k
      end do

      r_z0(i,j)=1.0
      r_ilmo(i,j)=-0.10+i*0.10
      r_hBound(i,j)=100./max(r_ilmo(i,j),1.e-9)
      r_lat(i,j)=1.0
    end do
  end do

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/ 0.0486058, -0.0092058,146.7788239,  0.7675956,147.00/)
  r_stateAnswer(2,1,:) =(/-0.5064627, -0.7492866,146.7206573,  1.2096442,147.00/)

  r_derivAnswer(1,1,:) =(/-0.2252018,-0.1186490, 2.8057959, 29.9545460,-0.98530/)
  r_derivAnswer(2,1,:) =(/-3.3406687, 2.8799691, 1.9550450, 37.9158936, 1.03003/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat &
                     )




goto 768
! This test is sensitive to round-off error.  There are often a few bits that
! differ and cause a failure of the test, even though all is well

  !
  ! FOURTEENTH TEST
  ! FOURTEENTH TEST
  !
  ! N.B.:  This test will fail if not preceeded by test 13
  s_title = "TEST 14:  generic; cubic derivs; surface wind; ascending"
            ! This is the same as tests 8 (x-component) and 13 (y-component),
            ! except that surface wind extrapolation has been chosen.  Compared
            ! to the results of tests 8 and 13, surface wind extrapolation should
            ! apply only to the surface layer.
            !
            ! Specifically, r_levelsTarget(1:2) should have the same result as
            ! test number TWELVE x- and y-components, and should adjust the
            ! interpolation in the next layer above that [r_levelsTarget(4)].
            ! r_levelsTarget(3,5) should have the same result as test number 8
            ! (x-component) and as test number 13 (y-component).  The derivative
            ! in the lowest interval and below is modified somewhat from tests 8
            ! and 13 since the surface extrapolation ensures a smooth derivative
            ! at the lowest level.

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_y_derivIn    = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_y_stateIn(i,j,1) = 0.

      r_stateIn(i,j,2) = 10.
      r_y_stateIn(i,j,2) = 0.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + 10.*k
        r_y_stateIn(i,j,k) = 143. + k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
                                        ! r_zSrc, r_zDest NOT ignored by
                                        ! cubiclagrange for extrap=surfacewind
      r_zSrc (i,j,1) = 0.
      r_zSrc (i,j,2) = 80.
      r_zSrc (i,j,3) = 0.
      r_zSrc (i,j,4) = 0.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=12.*k
      end do

      r_z0(i,j)=1.0
      r_ilmo(i,j)=-0.10+i*0.10
      r_hBound(i,j)=100./max(r_ilmo(i,j),1.e-9)
      r_lat(i,j)=1.0
    end do
  end do


  s_interpType = 'cubicwithderivs'
  s_extrapType = 'surfacewind'

  r_stateAnswer(1,1,:)  =(/5.8367934, 7.3248677,137.3696594,10.6604824, 140.00/)
  r_y_stateAnswer(1,1,:)=(/0.0000000, 0.0000000,146.7788239, 0.7531265, 147.00/)

  r_stateAnswer(2,1,:)  =(/3.6305742, 5.3461494,137.3114929,10.7054071, 140.00/)
  r_y_stateAnswer(2,1,:)=(/0.1767197, 0.2142493,146.7206573, 0.7376503, 147.00/)


  r_derivAnswer(1,1,:)  =(/23.6505680,15.6162901,25.6568794,25.1656380,-0.9853/)
  r_y_derivAnswer(1,1,:)=(/-0.1282577,-0.2224571, 2.8057959,29.6905479,-0.9853/)

  r_derivAnswer(2,1,:)  =(/23.1958714,15.7657442,24.8061295,25.8812046, 1.03003/)
  r_y_derivAnswer(2,1,:)=(/-0.1782643,-0.5063466, 1.9550450,29.3040657, 1.03003/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat, &
                      r_y_stateIn, r_y_stateAnswer, r_y_derivIn,r_y_derivAnswer &
                     )





  !
  ! FIFTEENTH TEST
  ! FIFTEENTH TEST
  !
  s_title = "TEST 15:  generic; cubic Lagrange; surface wind; ascending"
            ! This is the same as the previous test, except that the
            ! interpolation has been changed to cubicLagrange.  In this case,
            ! surface extrapolation should apply to the surface layer as in the
            ! previous test [r_levelsTarget(1:2) should have the same result as
            ! test number FOURTEEN], and should adjust the interpolation in the
            ! next layer above that to use cubic with derivatives, albeit with a
            ! manufactured derivative [r_levelsTarget(4) should have a result
            ! that is different from that of test number FOURTEEN, also different
            ! from that of test numbers EIGHT and THIRTEEN, but similar to both
            ! of them], r_levelsTarget(5) will be the same because it is clamped
            ! extrapolation in both cases, but the rest [r_levelsTarget(3)]
            ! should be a little different.

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_derivIn      = r_derivIncreasing
  r_y_derivIn    = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD
  r_levelsTarget(1) = 0.90
  r_levelsTarget(2) = 1.13
  r_levelsTarget(4) = 1.30  ! INTERpolation range to be adjusted by extrapSurface


  ! Set the state values
  do j=1,n_NJ
    do i=1,n_NI
      r_stateIn(i,j,1) = 0.
      r_y_stateIn(i,j,1) = 0.

      r_stateIn(i,j,2) = 10.
      r_y_stateIn(i,j,2) = 0.
    end do
  end do
  do k=3,n_PTS_INIT
    do j=1,n_NJ
      do i=1,n_NI
        r_stateIn(i,j,k) = 100. + 10.*k
        r_y_stateIn(i,j,k) = 143. + k
      end do
    end do
  end do


  ! Set the roughness length
  ! (z0), inverse of Monin-Obukhov length (ilmo) and height of the boundary layer
  ! (hBound).  Set the height (in m) of the lowest source level above the surface
  ! (r_zSrc (i,j,2)) and of the surface itself (r_zSrc (i,j,1)).
  do j=1,n_NJ
    do i=1,n_NI
      r_zSrc (i,j,1) = 0.               !r_zSrc, r_zDest ignored by cubiclagrange
      r_zSrc (i,j,2) = 80.
      do k=1,n_PTS_TARGET
        r_zDest(i,j,k)=12.*k
      end do

      r_z0(i,j)=1.0
      r_ilmo(i,j)=-0.10+i*0.10
      r_hBound(i,j)=100./max(r_ilmo(i,j),1.e-9)
      r_lat(i,j)=1.0
    end do
  end do


  s_interpType = 'cubiclagrange'
  s_extrapType = 'surfacewind'

  r_stateAnswer(1,1,:) =(/5.8367934, 7.3248677,143.5442352,10.5384855, 140.00/)
  r_y_stateAnswer(1,1,:)=(/0.0000000,0.0000000,156.8477936, 0.6262307, 147.00/)

  r_stateAnswer(2,1,:) =(/3.6305742, 5.3461494,143.5442352,10.5883961, 140.00/)
  r_y_stateAnswer(2,1,:)=(/0.1767197,0.2142493,156.8477936, 0.6157413, 147.00/)


  r_derivAnswer(1,1,:)  =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000/)
  r_y_derivAnswer(1,1,:)=(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000/)

  r_derivAnswer(2,1,:)  =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000/)
  r_y_derivAnswer(2,1,:)=(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat, &
                      r_y_stateIn, r_y_stateAnswer, r_y_derivIn,r_y_derivAnswer &
                     )



 768 continue


  !
  ! SIXTEENTH TEST
  ! SIXTEENTH TEST
  !
  ! This defunct test used to test the old (pre-_X) interface





  !
  ! SEVENTEENTH TEST
  ! SEVENTEENTH TEST
  !
  s_title = "TEST 17:  generic; linear; fixed; ascending"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'linear'
  s_extrapType = 'fixed'

  r_stateAnswer(1,1,:) =(/0.8797802, 0.4842152, 0.3319850, 0.4000000,-0.5000000/)
  r_stateAnswer(2,1,:) =(/2.5639911,-0.6168757,-0.4014246, 0.4000000,-0.5000000/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )





  !
  ! EIGHTEENTH TEST
  ! EIGHTEENTH TEST
  !
  ! (The same as FIRST TEST, but with a different grid type.)
  s_title = "TEST 18:  unnormalized hybrid; cubic derivs; clamped; ascending"

!  n_gridType = N_GRID_TYPE_SIGMA
!  n_gridType = N_GRID_TYPE_PRESSURE
!  n_gridType = N_GRID_TYPE_GENERIC
!  n_gridType = N_GRID_TYPE_HYBRID
!  n_gridType = N_GRID_TYPE_ETA
  n_gridType = N_GRID_TYPE_HYBRID_NOTNORM

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubicwithderivs'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/1.0093997, 0.9305420, 0.2244062, 0.1708000, 1.0093997/)
  r_stateAnswer(2,1,:) =(/4.3297067, 1.1360878,-0.2317659,-0.1733000, 4.3297067/)

  r_derivAnswer(1,1,:) =(/0.0956022,-0.3624431,-1.1526172,-0.9853000, 0.0956022/)
  r_derivAnswer(2,1,:) =(/-0.3018352,-7.2491136,1.3028319, 1.0300300,-0.3018352/)

  !
  ! MAKE THE DATA REASONABLE FOR THE HYBRID GRID TYPE
  !
  ! convert the levels to reasonable hybrid values
  do i=1,n_PTS_INIT
    r_levelsInit(i) = r_levelsInit(i) / 3.2
  end do

  ! convert the levels to reasonable hybrid values
  do i=n_PTS_TARGET,2,-1
    r_levelsTarget(i) = r_levelsTarget(i-1) / 3.2
  end do
  r_levelsTarget(1) = r_levelsInit(1)
  r_levelsTarget(5) = r_levelsTarget(1) ! ensure that nothing is below 'ground'


! NOTE:  modifying the initial pref and rcoeff
  call m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT/2., r_RCOEFF_INIT*2, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )




  !
  ! NINETEENTH TEST
  ! NINETEENTH TEST
  !
  ! (The same as THIRD TEST, but with arrays that do not start at zero, nor end
  !  at n_VLevels.)
  s_title = "TEST 19:  array bounds different from 1:n_VLevels"

  n_gridType = N_GRID_TYPE_GENERIC

  r_levelsInit   = r_LEVELS_INCREASING

  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'cubiclagrange'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.9099222, 0.5043430, 0.3516999, 0.5971954, 0.1708000/)
  r_stateAnswer(2,1,:) =(/3.0054035,-1.0220673,-0.8364134, 0.7445440,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  call m_testOneCombo_FunnyBounds &
                     (s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT, r_RCOEFF_INIT, &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP &
                     )




  !
  ! TWENTIETH TEST
  ! TWENTIETH TEST
  !
  ! (The same as the first test, but with staggered levels.)
  s_title = "TEST 20:  staggered vertical levels"

  n_gridType = N_GRID_TYPE_STAGGERED

  r_levelsInit   = r_LEVELS_INCREASING
  r_stateIn      = r_stateIncreasing
  r_derivIn      = r_derivIncreasing
  r_levelsTarget = r_LEVELS_TARGET_STD

  s_interpType = 'linear'
  s_extrapType = 'clamped'

  r_stateAnswer(1,1,:) =(/0.9473432, 0.8168903, 0.3669596, 0.2841619, 0.1708000/)
  r_stateAnswer(2,1,:) =(/2.9887292, 1.3323874,-0.4509242,-0.3337408,-0.1733000/)

  r_derivAnswer(1,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)
  r_derivAnswer(2,1,:) =(/0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000/)

  !
  ! MAKE THE DATA REASONABLE FOR THE HYBRID GRID TYPE
  !
  ! convert the levels to reasonable hybrid values
  do i=1,n_PTS_INIT
    r_levelsInit(i) = r_levelsInit(i) / 3.2
  end do

  ! convert the levels to reasonable hybrid values
  do i=n_PTS_TARGET,2,-1
    r_levelsTarget(i) = r_levelsTarget(i-1) / 3.5
  end do
  r_levelsTarget(1) = r_levelsInit(1)
  r_levelsTarget(5) = 0.90

write(6,*)"JWB:  in test jacket, stateIn="
do i=1,n_NI
  write(6,'((10f12.7))') ((r_stateIn(i,j,k),k=1,n_PTS_INIT),j=1,n_NJ)
end do


! NOTE:  modifying the initial pref and rcoeff
  call m_testOneCombo_staggered &
                     (s_title, n_gridType, s_interpType, s_extrapType, &

                      r_levelsInit,   r_stateIn , r_derivIn, &
                      r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                      r_EXTRAP_GUIDE_DOWN, r_EXTRAP_GUIDE_UP, &

                      r_PTOP_INIT, r_PREF_INIT/2., r_RCOEFF_INIT*2., &
                      r_PTOP_TARGET, r_PREF_TARGET, r_RCOEFF_TARGET, &
                      r_PSURF, r_PTOP, &

                      r_RCOEFF_INIT*2., r_RCOEFF_TARGET &
                     )




  ! Report the overall test status
  if(l_pass) then
    write(6,*)'*  T E S T   P A S S E D  *'
    write(6,"(' *     (', I1, '-byte reals)      *')")test48
  else
    write(6,*)'* * * * * * * * * * * * * *'
    write(6,*)'*                         *'
    write(6,*)'*  T E S T   F A I L E D  *'
    write(6,"(' *     (', I1, '-byte reals)      *')")test48
    write(6,*)'*                         *'
    write(6,*)'* * * * * * * * * * * * * *'
  end if

contains

!!!s/r m_testOneCombo - routine that tests a single combination of parameters
subroutine m_testOneCombo(s_title, n_gridType, s_interpType, s_extrapType, &

                          r_levelsInit,   r_stateIn , r_derivIn, &
                          r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                          r_extrapGuideDown, r_extrapGuideUp, &

                          r_pTopInit, r_pRefInit, r_rCoefInit, &
                          r_pTopTarget, r_pRefTarget, r_rCoefTarget, &
                          r_pSurf, r_pTop, &

                          r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat, &
                          r_y_stateIn,  r_y_stateAnswer, &
                          r_y_derivIn, r_y_derivAnswer &
                         )
!
!AUTHOR
!     J.W. Blezius OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - formalized from existing non-automatic test
!
!OBJECT
!        To test the ez_interpv package, with its ViIfc interface.
!
!ARGUMENTS
  implicit none
  include "ViConstants_f90.h"
  include "VertInterp_f90.h"

                                        ! parameters of most interest
  character(*), intent(in) :: s_title
  integer, intent(in) :: n_gridType
  character(*), intent(in) :: s_interpType, s_extrapType

                                        ! input data for the interpolation and
                                        ! the expected results
  real, dimension(:), intent(in) :: r_levelsInit, r_levelsTarget
  real, dimension(:,:,:), intent(in) :: r_stateIn , r_derivIn, &
                                        r_stateAnswer, r_derivAnswer

                                        ! more interpolation parameters
  real, intent(in) :: r_extrapGuideDown, r_extrapGuideUp

                                        ! grid parameters
  real, intent(in) :: r_pTopInit, r_pRefInit, r_rCoefInit, &
                      r_pTopTarget, r_pRefTarget, r_rCoefTarget
  real, dimension(:,:), intent(in) :: r_pSurf, r_pTop
  real, dimension(:,:,:), optional, intent(in) :: r_zSrc, r_zDest

  ! The next four parameters are used only for surface extrapolation
                                        ! roughness length
  real, dimension(:,:), optional, intent(in) :: r_z0
                                        ! inverse Monin-Obukhov length
  real, dimension(:,:), optional, intent(in) :: r_ilmo
                                        ! height of the boundary layer
  real, dimension(:,:), optional, intent(in) :: r_hBound
                                        ! latitude (used only for the wind)
  real, dimension(:,:), optional, intent(in) :: r_lat
  real, dimension(:,:,:), optional, intent(in) :: r_y_stateIn, r_y_stateAnswer, &
                                                  r_y_derivIn, r_y_derivAnswer
!
!NOTES
!        Assume that both the initial and target grid types are the same.
!
!!
  integer :: n_numExtArraysIn ! size of the array, r_ExtArraysIn
  integer :: n_numExtArraysOut! size of the array, r_ExtArraysOut
  real, dimension(ubound(r_stateIn,1), &
                  ubound(r_stateIn,2), &
                  3*ubound(r_stateIn,3)+ubound(r_stateAnswer,3)) :: r_ExtArraysIn
  real, dimension(ubound(r_stateAnswer,1), &
                  ubound(r_stateAnswer,2), &
                  2*ubound(r_stateAnswer,3)) :: r_ExtArraysOut

                                        ! a place to hold the results
  real, dimension(ubound(r_stateAnswer,1), &
                  ubound(r_stateAnswer,2), &
                  ubound(r_stateAnswer,3)) :: r_stateOut   , r_derivOut, &
                                              r_y_stateOut , r_y_derivOut

  integer :: i, j, k, n_ni, n_nj, n_nk

  integer :: n_gridIndexInitial, n_gridIndexTarget

  character(len=19) :: s_pass     = '  PASS', &
                       s_fail     = '  **** F A I L ****', &
                       s_passFail = '  **** T E M P ****'

  write(6,*) '\n', s_title

  n_ni = ubound(r_stateAnswer,1)
  n_nj = ubound(r_stateAnswer,2)
  n_nk = ubound(r_stateAnswer,3)



  ! Clear the destination tables
  r_stateOut=0.
  r_derivOut=0.
  r_y_stateOut=0.
  r_y_derivOut=0.

  !
  ! CREATE AND SET THE INITIAL AND TARGET GRIDS
  !
  error=N_ViqkdefIfc_X(n_gridIndexInitial, n_PTS_INIT, n_gridType, &
                       r_levelsInit, r_pTopInit, r_pRefInit, r_rCoefInit)
  if(error /= 0)write(6,*)'ERROR initializing gridInitial:  ', error

  n_numExtArraysOut = 0
  n_numExtArraysIn = 4
  if (present(r_z0)) then
    r_ExtArraysIn(:,:,1) = r_z0
    r_ExtArraysIn(:,:,2) = r_ilmo
    r_ExtArraysIn(:,:,3) = r_hBound
    r_ExtArraysIn(:,:,4) = r_lat
! else don't worry about the values; they won't be used anyway
  end if

  error=N_ViqkdefIfc_X(n_gridIndexTarget, n_PTS_TARGET, n_gridType, &
                       r_levelsTarget, r_pTopTarget, r_pRefTarget, &
                       r_rCoefTarget)
  if(error /= 0)write(6,*)'ERROR initializing gridTarget:  ', error


  error=N_VidefsetIfc_X(n_NI, n_NJ, n_gridIndexTarget, n_gridIndexInitial, &
                        r_pSurf, r_pTop, &
                        n_numExtArraysIn, n_numExtArraysOut, &
                        r_ExtArraysIn, r_ExtArraysOut)
  if(error /= 0) write(6,*) 'ERROR in test:  videfset returned ', error


  !
  ! SET THE INTERPOLATION OPTIONS
  !
  error=N_VisetoptIfc('interptype', s_interpType)
  if(error /= 0) then
    write(6,*) 'ERROR setting interptype:  N_VisetoptIfc returned ', error
  end if

  error=N_VisetoptIfc('extraptype', s_extrapType)
  if(error /= 0) then
    write(6,*) 'ERROR setting s_extrapType:  N_VisetoptIfc returned ', error
  end if


  !
  ! PERFORM THE INTERPOLATION / EXTRAPOLATION
  !
  n_numExtArraysOut = ubound(r_ExtArraysOut,3)

  n_numExtArraysIn = ubound(r_ExtArraysIn,3)
  if (present(r_zSrc)) then
    r_ExtArraysIn(:,:,1:ubound(r_stateOut,3)) = r_zDest
    r_ExtArraysIn(:,:,ubound(r_stateOut,3)+1: &
                      ubound(r_stateOut,3)+ubound(r_stateIn,3)) = r_zSrc
  end if
  if (present(r_y_stateIn)) then
    r_ExtArraysIn(:,:,ubound(r_stateOut,3)+ubound(r_stateIn,3)+1: &
                      ubound(r_stateOut,3)+2*ubound(r_stateIn,3)) = r_y_stateIn
    r_ExtArraysIn(:,:,ubound(r_stateOut,3)+2*ubound(r_stateIn,3)+1: &
                      ubound(r_stateOut,3)+3*ubound(r_stateIn,3)) = r_y_derivIn

! else don't worry about the values; they won't be used anyway
  end if

                                        ! Initialize r_ExtArraysOut
  r_ExtArraysOut(:,:,1 : &
                       ubound(r_stateOut,3)) = r_y_stateOut
  r_ExtArraysOut(:,:,  ubound(r_stateOut,3)+1 : &
                     2*ubound(r_stateOut,3)) = r_y_derivOut

  if(s_extrapType == 'surfacewind') then
    n_numExtArraysIn = n_PTS_TARGET + 3*n_PTS_INIT
    n_numExtArraysOut = 2*n_PTS_TARGET
                                        ! This is just a lazy way to call the
                                        ! WIND stubs
    error = N_VisintIfc_X(r_stateOut, r_stateIn, r_derivOut, r_derivIn, &
                          r_extrapGuideDown, r_extrapGuideUp, &
                          m_slStateValueWindStub, m_slFluxGradientWindStub, &
                          n_numExtArraysIn, n_numExtArraysOut, &
                          r_ExtArraysIn, r_ExtArraysOut &
                         )

  else 
    if(s_extrapType == 'surface') then
      n_numExtArraysIn = n_PTS_TARGET + n_PTS_INIT
      n_numExtArraysOut = 0
    else

      n_numExtArraysIn = 0
      n_numExtArraysOut = 0
    end if

    error = N_VisintIfc_X(r_stateOut, r_stateIn, r_derivOut, r_derivIn, &
                          r_extrapGuideDown, r_extrapGuideUp, &
                          m_slStateValueStub, m_slFluxGradientStub, &
                          n_numExtArraysIn, n_numExtArraysOut, &
                          r_ExtArraysIn, r_ExtArraysOut &
                         )
  end if

  r_y_stateOut = r_ExtArraysOut(:,:,1 : &
                                      ubound(r_stateOut,3))
  r_y_derivOut = r_ExtArraysOut(:,:,  ubound(r_stateOut,3)+1 : &
                                    2*ubound(r_stateOut,3))

  if(error /= 0) then
    write(6,*) 'ERROR interpolating:  N_VisintIfc_X returned ', error
  end if


  !
  ! RELEASE THE GRIDS
  !
  error = N_VigdrlsIfc(n_gridIndexInitial)
  error = N_VigdrlsIfc(n_gridIndexTarget)


  !
  ! VERIFY THE RESULTS
  !
  s_passFail = s_pass
  do k=1, n_nk
    do j=1,n_nj
      do i=1,n_ni
        if (     abs(r_stateOut(i,j,k)   - r_stateAnswer(i,j,k)  ) > 8e-6 &
            .or. abs(r_derivOut(i,j,k  ) - r_derivAnswer(i,j,k)  ) >11e-6) then
          l_pass = .false.
          s_passFail = s_fail
          exit
        end if
        if(present(r_y_stateAnswer))then
          if (     abs(r_y_stateOut(i,j,k) - r_y_stateAnswer(i,j,k)) > 1e-6 &
              .or. abs(r_y_derivOut(i,j,k) - r_y_derivAnswer(i,j,k)) > 1e-6) then
            l_pass = .false.
            s_passFail = s_fail
            exit
          end if
        end if
      end do
    end do
  end do

  write(6,*) s_passFail
  write(6,*)'stateOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_stateOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
  end do

  write(6,*)'derivOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_derivOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
  end do

  if(present(r_y_stateAnswer))then
    write(6,*)'y_stateOut='
    do i=1,n_NI
      write(6,'((10f12.7))') ((r_y_stateOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
    end do

    write(6,*)'y_derivOut='
    do i=1,n_NI
      write(6,'((10f12.7))') ((r_y_derivOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
    end do
  end if


end subroutine m_testOneCombo




!!!s/r m_testOneCombo_FunnyBounds - routine that tests a single combination of parameters, but with bounds different from 1:n_Vlevels
subroutine m_testOneCombo_FunnyBounds(s_title, n_gridType, s_interpType, s_extrapType, &

                          r_levelsInit,   r_stateIn , r_derivIn, &
                          r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                          r_extrapGuideDown, r_extrapGuideUp, &

                          r_pTopInit, r_pRefInit, r_rCoefInit, &
                          r_pTopTarget, r_pRefTarget, r_rCoefTarget, &
                          r_pSurf, r_pTop, &

                          r_zSrc, r_zDest, r_z0, r_ilmo, r_hBound, r_lat, &
                          r_y_stateIn,  r_y_stateAnswer, &
                          r_y_derivIn, r_y_derivAnswer &
                         )
!
!AUTHOR
!     J.W. Blezius JUNE 2010
!
!REVISION
! ?       Blezius J.W. JUN 2010 - copied from m_testOneCombo
!
!OBJECT
!        To test the ez_interpv package, with its ViIfc interface.  But, more
!        importantly, to test the interpolation when the arrays are presented
!        with bounds that are not 1:n_Vlevels
!
!ARGUMENTS
  implicit none
  include "ViConstants_f90.h"
  include "VertInterp_f90.h"

                                        ! parameters of most interest
  character(*), intent(in) :: s_title
  integer, intent(in) :: n_gridType
  character(*), intent(in) :: s_interpType, s_extrapType

                                        ! input data for the interpolation and
                                        ! the expected results
  real, dimension(:), intent(in) :: r_levelsInit, r_levelsTarget
  real, dimension(:,:,:), intent(in) :: r_stateIn , r_derivIn, &
                                        r_stateAnswer, r_derivAnswer

                                        ! more interpolation parameters
  real, intent(in) :: r_extrapGuideDown, r_extrapGuideUp

                                        ! grid parameters
  real, intent(in) :: r_pTopInit, r_pRefInit, r_rCoefInit, &
                      r_pTopTarget, r_pRefTarget, r_rCoefTarget
  real, dimension(:,:), intent(in) :: r_pSurf, r_pTop
  real, dimension(:,:,:), optional, intent(in) :: r_zSrc, r_zDest

  ! The next four parameters are used only for surface extrapolation
                                        ! roughness length
  real, dimension(:,:), optional, intent(in) :: r_z0
                                        ! inverse Monin-Obukhov length
  real, dimension(:,:), optional, intent(in) :: r_ilmo
                                        ! height of the boundary layer
  real, dimension(:,:), optional, intent(in) :: r_hBound
                                        ! latitude (used only for the wind)
  real, dimension(:,:), optional, intent(in) :: r_lat
  real, dimension(:,:,:), optional, intent(in) :: r_y_stateIn, r_y_stateAnswer, &
                                                  r_y_derivIn, r_y_derivAnswer
!
!NOTES
!        Assume that both the initial and target grid types are the same.
!
!        The vertical interpolator works with these funny bounds because:
!           - the call to qkdef supplies as a parameter the actual dimension of
!             the array; i.e. what the upper bound would have been if the lower
!             bound had been 1.
!           - (The same is true for the horizontal dimensions, except that they
!              are supplied to defset.)
!
!!
  integer :: n_numExtArraysIn ! size of the array, r_ExtArraysIn
  integer :: n_numExtArraysOut! size of the array, r_ExtArraysOut
  real, dimension(ubound(r_stateIn,1), &
                  ubound(r_stateIn,2), &
                  3*ubound(r_stateIn,3)+ubound(r_stateAnswer,3)) :: r_ExtArraysIn
  real, dimension(ubound(r_stateAnswer,1), &
                  ubound(r_stateAnswer,2), &
                  2*ubound(r_stateAnswer,3)) :: r_ExtArraysOut

  ! Variables used for resetting the arrays with different bounds
  integer, parameter :: n_BOUND_LOWER_INIT=3
  integer, parameter :: n_BOUND_UPPER_INIT=6 ! =n_BOUND_LOWER_INIT +n_PTS_INIT -1
  integer, parameter :: n_BOUND_LOWER_TARGET=5
  integer, parameter :: n_BOUND_UPPER_TARGET=9 ! =n_BOUND_LOWER_TARGET + n_PTS_TARGET -1

  real, dimension(n_BOUND_LOWER_INIT:n_BOUND_UPPER_INIT) :: r_levelsInit_Bd
  real, dimension(ubound(r_stateIn,1),  ubound(r_stateIn,2), &
                  n_BOUND_LOWER_INIT:n_BOUND_UPPER_INIT) :: r_stateIn_Bd, &
                                                            r_derivIn_Bd

  real, dimension(n_BOUND_LOWER_TARGET:n_BOUND_UPPER_TARGET)::r_levelsTarget_Bd
  real, dimension(ubound(r_stateIn,1),  ubound(r_stateIn,2), &
                  n_BOUND_LOWER_TARGET:n_BOUND_UPPER_TARGET)::r_stateAnswer_Bd, &
                                                              r_derivAnswer_Bd

                                        ! a place to hold the results
  real, dimension(ubound(r_stateAnswer,1), &
                  ubound(r_stateAnswer,2), &
                  n_BOUND_LOWER_TARGET:n_BOUND_UPPER_TARGET) :: &
                                              r_stateOut_Bd   , r_derivOut_Bd, &
                                              r_y_stateOut , r_y_derivOut

  integer :: i, j, k, n_ni, n_nj

  integer :: n_gridIndexInitial, n_gridIndexTarget

  character(len=19) :: s_pass     = '  PASS', &
                       s_fail     = '  **** F A I L ****', &
                       s_passFail = '  **** T E M P ****'

  write(6,*) '\n', s_title

  n_ni = ubound(r_stateAnswer,1)
  n_nj = ubound(r_stateAnswer,2)


  ! Transfer the input to bounded arrays
  do i=1,n_PTS_INIT
    r_levelsInit_Bd(i-1+n_BOUND_LOWER_INIT) = r_levelsInit(i)
    r_stateIn_Bd   (:,:,i-1+n_BOUND_LOWER_INIT) = r_stateIn(:,:,i)
    r_derivIn_Bd   (:,:,i-1+n_BOUND_LOWER_INIT) = r_derivIn(:,:,i)
  end do

  do i=1, n_PTS_TARGET
    r_levelsTarget_Bd(i-1+n_BOUND_LOWER_TARGET) = r_levelsTarget(i)
    r_stateAnswer_Bd (:,:,i-1+n_BOUND_LOWER_TARGET) = r_stateAnswer(:,:,i)
    r_derivAnswer_Bd (:,:,i-1+n_BOUND_LOWER_TARGET) = r_derivAnswer(:,:,i)
  end do


  ! Clear the destination tables
  r_stateOut_Bd=0.
  r_derivOut_Bd=0.
  r_y_stateOut=0.
  r_y_derivOut=0.

  !
  ! CREATE AND SET THE INITIAL AND TARGET GRIDS
  !
  error=N_ViqkdefIfc_X(n_gridIndexInitial, n_PTS_INIT, n_gridType, &
                       r_levelsInit_Bd, r_pTopInit, r_pRefInit, r_rCoefInit)
  if(error /= 0)write(6,*)'ERROR initializing gridInitial:  ', error

  n_numExtArraysOut = 0
  n_numExtArraysIn = 4
  if (present(r_z0)) then
    r_ExtArraysIn(:,:,1) = r_z0
    r_ExtArraysIn(:,:,2) = r_ilmo
    r_ExtArraysIn(:,:,3) = r_hBound
    r_ExtArraysIn(:,:,4) = r_lat
! else don't worry about the values; they won't be used anyway
  end if

  error=N_ViqkdefIfc_X(n_gridIndexTarget, n_PTS_TARGET, n_gridType, &
                       r_levelsTarget_Bd, r_pTopTarget, r_pRefTarget, &
                       r_rCoefTarget)
  if(error /= 0)write(6,*)'ERROR initializing gridTarget:  ', error


  error=N_VidefsetIfc_X(n_NI, n_NJ, n_gridIndexTarget, n_gridIndexInitial, &
                        r_pSurf, r_pTop, &
                        n_numExtArraysIn, n_numExtArraysOut, &
                        r_ExtArraysIn, r_ExtArraysOut)
  if(error /= 0) write(6,*) 'ERROR in test:  videfset returned ', error


  !
  ! SET THE INTERPOLATION OPTIONS
  !
  error=N_VisetoptIfc('interptype', s_interpType)
  if(error /= 0) then
    write(6,*) 'ERROR setting interptype:  N_VisetoptIfc returned ', error
  end if

  error=N_VisetoptIfc('extraptype', s_extrapType)
  if(error /= 0) then
    write(6,*) 'ERROR setting s_extrapType:  N_VisetoptIfc returned ', error
  end if


  !
  ! PERFORM THE INTERPOLATION / EXTRAPOLATION
  !
  n_numExtArraysOut = ubound(r_ExtArraysOut,3)

  n_numExtArraysIn = ubound(r_ExtArraysIn,3)
  if (present(r_zSrc)) then
    r_ExtArraysIn(:,:,:ubound(r_stateOut_Bd,3)) = r_zDest
    r_ExtArraysIn(:,:,ubound(r_stateOut_Bd,3)+1: &
                      ubound(r_stateOut_Bd,3)+ubound(r_stateIn,3)) = r_zSrc
  end if
  if (present(r_y_stateIn)) then
    r_ExtArraysIn(:,:,ubound(r_stateOut_Bd,3)+ubound(r_stateIn,3)+1: &
                      ubound(r_stateOut_Bd,3)+2*ubound(r_stateIn,3)) =r_y_stateIn
    r_ExtArraysIn(:,:,ubound(r_stateOut_Bd,3)+2*ubound(r_stateIn,3)+1: &
                      ubound(r_stateOut_Bd,3)+3*ubound(r_stateIn,3)) =r_y_derivIn

! else don't worry about the values; they won't be used anyway
  end if

                                        ! Initialize r_ExtArraysOut
  r_ExtArraysOut(:,:,1 : &
                       ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+1) = r_y_stateOut
  r_ExtArraysOut(:,:,  ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+2 : &
                     2*(ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+1)) = r_y_derivOut

  if(s_extrapType == 'surfacewind') then
    n_numExtArraysIn = n_PTS_TARGET + 3*n_PTS_INIT
    n_numExtArraysOut = 2*n_PTS_TARGET
                                        ! This is just a lazy way to call the
                                        ! WIND stubs
    error = N_VisintIfc_X(r_stateOut_Bd,r_stateIn_Bd,r_derivOut_Bd,r_derivIn_Bd,&
                          r_extrapGuideDown, r_extrapGuideUp, &
                          m_slStateValueWindStub, m_slFluxGradientWindStub, &
                          n_numExtArraysIn, n_numExtArraysOut, &
                          r_ExtArraysIn, r_ExtArraysOut &
                         )

  else 
    if(s_extrapType == 'surface') then
      n_numExtArraysIn = n_PTS_TARGET + n_PTS_INIT
      n_numExtArraysOut = 0
    else

      n_numExtArraysIn = 0
      n_numExtArraysOut = 0
    end if

    error = N_VisintIfc_X(r_stateOut_Bd,r_stateIn_Bd,r_derivOut_Bd,r_derivIn_Bd,&
                          r_extrapGuideDown, r_extrapGuideUp, &
                          m_slStateValueStub, m_slFluxGradientStub, &
                          n_numExtArraysIn, n_numExtArraysOut, &
                          r_ExtArraysIn, r_ExtArraysOut &
                         )
  end if

  r_y_stateOut = r_ExtArraysOut(:,:,1 : &
                                      ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+1)
  r_y_derivOut = r_ExtArraysOut(:,:,  ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+2 : &
                                    2*(ubound(r_stateOut_Bd,3)-lbound(r_stateOut_Bd,3)+1))

  if(error /= 0) then
    write(6,*) 'ERROR interpolating:  N_VisintIfc_X returned ', error
  end if


  !
  ! RELEASE THE GRIDS
  !
  error = N_VigdrlsIfc(n_gridIndexInitial)
  error = N_VigdrlsIfc(n_gridIndexTarget)


  !
  ! VERIFY THE RESULTS
  !
  s_passFail = s_pass
  do k=n_BOUND_LOWER_TARGET, n_BOUND_UPPER_TARGET
    do j=1,n_nj
      do i=1,n_ni
        if (     abs(r_stateOut_Bd(i,j,k)   - r_stateAnswer_Bd(i,j,k)  ) > 8e-6 &
            .or. abs(r_derivOut_Bd(i,j,k  ) - r_derivAnswer_Bd(i,j,k)  ) >11e-6)&
                                                                             then
          l_pass = .false.
          s_passFail = s_fail
          exit
        end if
        if(present(r_y_stateAnswer))then
          if (     abs(r_y_stateOut(i,j,k) - r_y_stateAnswer(i,j,k)) > 1e-6 &
              .or. abs(r_y_derivOut(i,j,k) - r_y_derivAnswer(i,j,k)) > 1e-6) then
            l_pass = .false.
            s_passFail = s_fail
            exit
          end if
        end if
      end do
    end do
  end do

  write(6,*) s_passFail
  write(6,*)'stateOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_stateOut_Bd(i,j,k),k=n_BOUND_LOWER_TARGET, &
                                                    n_BOUND_UPPER_TARGET), &
                                                  j=1,n_NJ)
  end do

  write(6,*)'derivOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_derivOut_Bd(i,j,k),k=n_BOUND_LOWER_TARGET, &
                                                    n_BOUND_UPPER_TARGET), &
                                                  j=1,n_NJ)
  end do

  if(present(r_y_stateAnswer))then
    write(6,*)'y_stateOut='
    do i=1,n_NI
      write(6,'((10f12.7))') ((r_y_stateOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
    end do

    write(6,*)'y_derivOut='
    do i=1,n_NI
      write(6,'((10f12.7))') ((r_y_derivOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
    end do
  end if


end subroutine m_testOneCombo_FunnyBounds






!!!s/r m_testOneCombo - routine that tests a single combination of parameters,
!                       but with straggered-grid parameters and the non-Ifc_X
!                       interface.
subroutine m_testOneCombo_staggered &
                         (s_title, n_gridType, s_interpType, s_extrapType, &

                          r_levelsInit,   r_stateIn , r_derivIn, &
                          r_levelsTarget, r_stateAnswer, r_derivAnswer, &

                          r_extrapGuideDown, r_extrapGuideUp, &

                          r_pTopInit, r_pRefInit, r_rCoefInit, &
                          r_pTopTarget, r_pRefTarget, r_rCoefTarget, &
                          r_pSurf, r_pTop, &

                          r_rCoef_2_Init, r_rCoef_2_Target &
                         )
!
!AUTHOR
!     J.W. Blezius OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - formalized from existing non-automatic test
!
!OBJECT
!        To test the ez_interpv package, with its ViIfc interface.
!
!ARGUMENTS
  use VerticalGrid_class, only: T_VerticalGrid, T_VerticalGridPtr, N_Viqkdef
  use VerticalInterpolation_class, only: N_Videfset, N_Visint
  implicit none
  include "ViConstants_f90.h"
  include "VertInterp_f90.h"

                                        ! parameters of most interest
  character(*), intent(in) :: s_title
  integer, intent(in) :: n_gridType
  character(*), intent(in) :: s_interpType, s_extrapType

                                        ! input data for the interpolation and
                                        ! the expected results
  real, dimension(:), intent(in) :: r_levelsInit, r_levelsTarget
  real, dimension(:,:,:), intent(in) :: r_stateIn , r_derivIn, &
                                        r_stateAnswer, r_derivAnswer

                                        ! more interpolation parameters
  real, intent(in) :: r_extrapGuideDown, r_extrapGuideUp

                                        ! grid parameters
  real, intent(in) :: r_pTopInit, r_pRefInit, r_rCoefInit, &
                      r_pTopTarget, r_pRefTarget, r_rCoefTarget, &
                      r_rCoef_2_Init, r_rCoef_2_Target
  real, dimension(:,:), intent(in) :: r_pSurf, r_pTop
!
!NOTES
!        Assume that both the initial and target grid types are the same.
!
!!

                                        ! a place to hold the results
  real, dimension(ubound(r_stateAnswer,1), &
                  ubound(r_stateAnswer,2), &
                  ubound(r_stateAnswer,3)) :: r_stateOut   , r_derivOut, &
                                              r_y_stateOut , r_y_derivOut

  integer :: i, j, k, n_ni, n_nj, n_nk

  type(T_VerticalGrid), target:: o_gridInitial, o_gridTarget
  type(T_VerticalGridPtr):: o_gridInitial_p, o_gridTarget_p

  character(len=19) :: s_pass     = '  PASS', &
                       s_fail     = '  **** F A I L ****', &
                       s_passFail = '  **** T E M P ****'

  o_gridInitial_p%Ptr => o_gridInitial
  o_gridTarget_p%Ptr  => o_gridTarget

  write(6,*) '\n', s_title

  n_ni = ubound(r_stateAnswer,1)
  n_nj = ubound(r_stateAnswer,2)
  n_nk = ubound(r_stateAnswer,3)



  ! Clear the destination tables
  r_stateOut=0.
  r_derivOut=0.
  r_y_stateOut=0.
  r_y_derivOut=0.

  !
  ! CREATE AND SET THE INITIAL AND TARGET GRIDS
  !
  error=N_Viqkdef     (o_gridInitial_p, n_PTS_INIT, n_gridType, &
                       r_levelsInit, r_pTopInit, r_pRefInit, r_rCoefInit, &
                       r_rCoef_2_Init)
  if(error /= 0)write(6,*)'ERROR initializing gridInitial:  ', error

  error=N_Viqkdef     (o_gridTarget_p, n_PTS_TARGET, n_gridType, &
                       r_levelsTarget, r_pTopTarget, r_pRefTarget, &
                       r_rCoefTarget, r_rCoef_2_Target)
  if(error /= 0)write(6,*)'ERROR initializing gridTarget:  ', error


  error=N_Videfset     (n_NI, n_NJ, o_gridTarget_p, o_gridInitial_p, &
                        r_pSurf, r_pTop)
  if(error /= 0) write(6,*) 'ERROR in test:  N_Videfset returned ', error


  !
  ! SET THE INTERPOLATION OPTIONS
  !
  error=N_VisetoptIfc('interptype', s_interpType)
  if(error /= 0) then
    write(6,*) 'ERROR setting interptype:  N_VisetoptIfc returned ', error
  end if

  error=N_VisetoptIfc('extraptype', s_extrapType)
  if(error /= 0) then
    write(6,*) 'ERROR setting s_extrapType:  N_VisetoptIfc returned ', error
  end if


  !
  ! PERFORM THE INTERPOLATION / EXTRAPOLATION
  !
  error = N_Visint     (r_stateOut, r_stateIn, r_derivOut, r_derivIn, &
                        r_extrapGuideDown, r_extrapGuideUp, &
                        m_slStateValueStub, m_slFluxGradientStub &
                       )
  if(error /= 0) then
    write(6,*) 'ERROR interpolating:  N_Visint returned ', error
  end if


  !
  ! VERIFY THE RESULTS
  !
  s_passFail = s_pass
  do k=1, n_nk
    do j=1,n_nj
      do i=1,n_ni
        if (     abs(r_stateOut(i,j,k)   - r_stateAnswer(i,j,k)  ) > 8e-6 &
            .or. abs(r_derivOut(i,j,k)   - r_derivAnswer(i,j,k)  ) >11e-6) then
          l_pass = .false.
          s_passFail = s_fail
          exit
        end if
      end do
    end do
  end do

  write(6,*) s_passFail
  write(6,*)'stateOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_stateOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
  end do

  write(6,*)'derivOut='
  do i=1,n_NI
    write(6,'((10f12.7))') ((r_derivOut(i,j,k),k=1,n_PTS_TARGET),j=1,n_NJ)
  end do


end subroutine m_testOneCombo_staggered
end program











!#include "phy_macros_f.h":!copyright (C) 2001  MSC-RPN COMM  %%%RPNPHY%%%
#ifdef DOC
!
! Successive calls to the following macros generate
! two common blocks:
!
!    * MARK_COMPHY_BEG: marks the beginning of the common block
!      of "pointers" (of type INTEGER) that define the structure
!      of the bus
!    * MARK_COMPHY_END: marks the end of the same common block
!    * DCL_PHYVAR: this macro has to be called for each variable
!      included in the bus. If DCLCHAR is not defined, then only
!      the common block of "pointers" is created. If DCLCHAR is
!      defined, then both the common block of "pointers" and the
!      common block of the corresponding "names" (of type CHARACTER)
!      are created.
!
! Example:
!       SUBROUTINE BIDON
! #define DCLCHAR
! #include "phy_macros_f.h"
!       MARK_COMPHY_BEG (phybus)           ! Begins the common block "phybus"
!       DCL_PHYVAR( AL        ,phybus)     ! Adds one "pointer" to the common block
!       DCL_PHYVAR( MG        ,phybus)
!       ...
!       DCL_PHYVAR( Z0        ,phybus)
!       MARK_COMPHY_END (phybus)           ! Ends the common block "phybus"
!       equivalence (phybus_i_first(1),AL) ! "pointer" AL is now the first element
!                                            of the common block "phybus"
!       ...
!       return
!       end
!
! For details of implementation, see comdeck "phybus.cdk"
! and subroutine "phy_ini.ftn" in the physics library.
!
! Author : Vivian Lee (Nov 2000) - adapted by B. Bilodeau
!
#endif

#define _cat_(name1,name2) name1##name2

#define _cat3_(name1,name2,name3) name1##name2##name3

#define AUTOMATIC(name,type,dims) ~~\
type _cat_(name,dims)

#ifndef DCLCHAR

#define DCL_PHYVAR(__TOKEN__,_COM_)~~\
integer __TOKEN__~~\
common/_cat_(_COM_,_i)/__TOKEN__~~\

#define MARK_COMPHY_BEG(_COM_) ~~\
integer _cat3_(_COM_,_i,_first(-1:0))~~\
common /_cat_(_COM_,_i)/_cat3_(_COM_,_i,_first)

#else

#define DCL_PHYVAR(__TOKEN__,_COM_)~~\
integer __TOKEN__~~\
character*8 _cat_(__TOKEN__,_c)~~\
data  _cat_(__TOKEN__,_c) /'__TOKEN__'/~~\
common/_cat_(_COM_,_i)/__TOKEN__~~\
common/_cat_(_COM_,_c)/_cat_(__TOKEN__,_c)

#define MARK_COMPHY_BEG(_COM_)~~\
integer _cat3_(_COM_,_i,_first(-1:0))~~\
common /_cat_(_COM_,_i)/_cat3_(_COM_,_i,_first)~~\
character*8 _cat3_(_COM_,_c,_first(-1:0))~~\
common /_cat_(_COM_,_c)/_cat3_(_COM_,_c,_first)

#endif

#define MARK_COMPHY_END(_COM_)~~\
integer _cat3_(_COM_,_i,_last)~~\
common /_cat_(_COM_,_i)/_cat3_(_COM_,_i,_last)

#define COMPHY_SIZE(_COM_) (loc(_cat3_(_COM_,_i,_last))-\
loc(_cat3_(_COM_,_i,_first(0)))-1)/(loc(_cat3_(_COM_,_i,_first(0)))-\
loc(_cat3_(_COM_,_i,_first(-1))))
!end of #include "phy_macros_f.h"




!!s/r m_slFluxGradientStub - Testing stub for the FluxGradient routine
subroutine m_slFluxGradientStub(ft,dtdz,ttop,tsurf,ztop,z0t,ilmo,h,n)
!!$subroutine m_slFluxGradientStub(r_ft, &
!!$                            r_dtdz, &
!!$                            r_stateIn(:,:,n_indexSurface_plus1), &
!!$                            r_stateIn(:,:,n_indexSurface), &
!!$                            r_zSrc(:,:,n_indexSurface_plus1), &
!!$                            r_z0_a, &
!!$                            r_ilmo_a, &
!!$                            r_hBound_a, &
!!$                            n_ni*n_nj)
!
!AUTHOR
!     Y. Delage    OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - extracted from the physics library
!
!OBJECT
!        To fill the role, in part, of the physics library during testing.  The
!        routine is copied here so as to keep this test independent of changes in
!        the physics library.
!
!        Calculates the surface flux and the slope of the temperature
!        or humidity profile at the top of the surface layer (SL)
!
!ARGUMENTS
      IMPLICIT NONE
      INTEGER N
      REAL FT(N),DTDZ(N),TTOP(N),TSURF(N),ZTOP(N),Z0T(N)
      REAL ILMO(N),H(N)

!          - Output -
! FT      normalised temperature or humidity flux at surface
! DTDZ    slope of temperature or humidity profile at top of SL
!
!          - Input -
! TTOP    temperature or humidity at the top of surface layer
! TSURF   temperature or humidity at the surface
! ZTOP    height of the top of the surface layer
! Z0T     roughness length for temperature/humidity
! ILMO    inverse of MONIN-OBUKHOV lenth
! H       height of boundary layer (for stable case only)
! N       number of horizontal points to process
!
!NOTES
!        This routine was supplied from the physics library by Yves Delage, who
!        called it sltop_tq, and put together by J.W. Blezius.
!
!!

      INTEGER J

!***************************************************************
!     AUTOMATIC ARRAYS
      AUTOMATIC ( FH , REAL , (N) )
!***************************************************************
      REAL AS,ASX,CI,BS,BETA,FACTN,HMIN,ANGMAX
!
!#include "surfcon_ini.cdk":
! Initilisation of constants in the common SURFCON
!
! Note: some of the constants may be reinitialised at runtime using a namelist

      AS    = 12.
      ASX   = 5.
      CI    = 40.
      BS    = 1.0
      BETA  = 1.0
      FACTN = 1.2
      HMIN  = 30.
      ANGMAX= 0.85

! end of #include "surfcon_ini.cdk"

      call m_slStateValueStub(fh,ztop,z0t,ilmo,h,n)
      DO J=1,N
        ft(j)=(ttop(j)-tsurf(j))/fh(j)
        dtdz(j)=ft(j)*phih(ztop(j),ilmo(j),h(j))/(ztop(j)+z0t(j))
      END DO
!
      return


CONTAINS
!#include "deriv_stabfunc.cdk":
!  Derivatives of the stability functions

        REAL FUNCTION PHIM(Z,ILMO,H)

        REAL Z,ILMO,H,HH

        HH=MAX(1-Z/H,FACTN-1.0)
        IF(ILMO.GT.0.) THEN
           PHIM=MIN(1.+ASX*BETA*Z*ILMO,0.5*(HH+SQRT(HH**2+ &
                4.*AS*BETA*Z*ILMO*HH)))
        ELSE
           PHIM=(1.-CI*BETA*Z*ILMO)**(-.1666666)
        END IF
        RETURN
        END FUNCTION

        REAL FUNCTION PHIH(Z,ILMO,H)

        REAL Z,ILMO,H,HH

        HH=MAX(1-Z/H,FACTN-1.0)
        IF(ILMO.GT.0.) THEN
           PHIH=BETA*MIN(1.+ASX*BETA*Z*ILMO,0.5*(HH+SQRT(HH**2+ &
                4.*AS*BETA*Z*ILMO*HH)))
        ELSE
           PHIH=(1.-CI*BETA*Z*ILMO)**(-.333333333)
        END IF
        RETURN
        END FUNCTION


!end of #include "deriv_stabfunc.cdk"
end subroutine m_slFluxGradientStub








!!s/r m_slStateValueStub - Testing stub for the StateValue routine
!#include "phy_macros_f.h" -- already included before the previous routine
subroutine m_slStateValueStub(fh,z,z0t,ilmo,h,n)
!subroutine m_slStateValueStub(f,zz,z0,ilmo,h,n)
!
!AUTHOR
!     Y. Delage    OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - extracted from the physics library
!
!OBJECT
!        To fill the role, in part, of the physics library during testing.  The
!        routine is copied here so as to keep this test independent of changes in
!        the physics library.
!
!        Calculates the integrated surface-layer functions for interpolating
!        temperature, humidity, and other passive variables.
!
!ARGUMENTS
      IMPLICIT NONE
      INTEGER N
      REAL FH(N),Z(N),Z0T(N),ILMO(N),H(N)
!
!          - Output -
! FH      normalised temperature or humidity value at desired height
!
!          - Input -
! Z       height of desired output
! Z0T     roughness length for temperature/humidity
! ILMO    inverse of MONIN-OBUKHOV lenth
! H       height of boundary layer (for stable case only)
! N       number of horizontal points to process
!
!NOTES
!        This routine was supplied from the physics library by Yves Delage, who
!        called it slfun_tq, and put together by J.W. Blezius.
!
!!

      INTEGER J
      REAL AS,ASX,CI,BS,BETA,FACTN,HMIN,ANGMAX

      REAL RAC3,X,X0,Y,Y0,Z0(1),HI,LZZ0(1)

!********************************************************************
!     AUTOMATIC ARRAYS
      AUTOMATIC ( LZZ0T , REAL , (N) )
!********************************************************************

!#include "surfcon_ini.cdk":
! Initilisation of constants in the common SURFCON
!
! Note: some of the constants may be reinitialised at runtime using a namelist

      AS    = 12.
      ASX   = 5.
      CI    = 40.
      BS    = 1.0
      BETA  = 1.0
      FACTN = 1.2
      HMIN  = 30.
      ANGMAX= 0.85

! end of #include "surfcon_ini.cdk"

      RAC3=SQRT(3.)

      DO J=1,N
      LZZ0T(J)=LOG(Z(J)/Z0T(J)+1)
      IF(ILMO(J).LE.0.) THEN
!---------------------------------------------------------------------
!                      UNSTABLE CASE
           FH(J)= fhi(z(j)+z0t(j),j)
      ELSE
!---------------------------------------------------------------------
!                        STABLE CASE
        hi=1/MAX(H(J),hmin,factn/(4*AS*BETA*ilmo(j)), &
             (Z(J)+10*Z0T(J))*factn)
        fh(j)=BETA*(LZZ0T(J)+min(psi(Z(J)+Z0T(J),j)-psi(Z0T(J),j), &
                           ASX*BETA*ILMO(J)*Z(J))) 
      ENDIF
!---------------------------------------------------------------------
      END DO

      return


CONTAINS
!#include "stabfunc.cdk":
!   Internal function FMI
!   Stability function for momentum in the unstable regime (ilmo<0)
!   Reference: Delage Y. and Girard C. BLM 58 (19-31) Eq. 19

      REAL FUNCTION FMI(Z,I)

      REAL Z
      integer i

      X=(1-CI*Z*BETA*ILMO(I))**(0.1666666)
      X0=(1-CI*Z0(I)*BETA*ILMO(I))**(0.1666666)
      FMI=LZZ0(I)+LOG((X0+1)**2*SQRT(X0**2-X0+1)*(X0**2+X0+1)**1.5 &
                     /((X+1)**2*SQRT(X**2-X+1)*(X**2+X+1)**1.5)) &
                    +RAC3*ATAN(RAC3*((X**2-1)*X0-(X0**2-1)*X)/ &
                    ((X0**2-1)*(X**2-1)+3*X*X0))

      RETURN
      END FUNCTION

!   Internal function FHI
!   Stability function for heat and moisture in the unstable regime (ilmo<0)
!   Reference: Delage Y. and Girard C. BLM 58 (19-31) Eq. 17

      REAL FUNCTION FHI(Z,I)

      REAL Z
      integer i

      Y=(1-CI*Z*BETA*ILMO(I))**(0.33333333)
      Y0=(1-CI*Z0T(I)*BETA*ILMO(I))**(0.3333333)
      FHI=BETA*(LZZ0T(I)+1.5*LOG((Y0**2+Y0+1)/(Y**2+Y+1))+RAC3* &
              ATAN(RAC3*2*(Y-Y0)/((2*Y0+1)*(2*Y+1)+3)))

      RETURN
      END FUNCTION

!   Internal function psi
!   Stability function for momentum in the stable regime (unsl>0)
!   Reference :  Y. Delage, BLM, 82 (p23-48) (Eqs.33-37)

      REAL FUNCTION PSI(Z,I)

      REAL Z,a,b,c,d
      integer i

      d = 4*AS*BETA*ilmo(i)
      c = d*hi - hi**2
      b = d - 2*hi
      a = sqrt(1 + b*z - c*z**2)
      psi = 0.5 * (a-z*hi-log(1+b*z*0.5+a)- &
                  b/(2*sqrt(c))*asin((b-2*c*z)/d))

      RETURN
      END FUNCTION
! end of #include "stabfunc.cdk"
end subroutine m_slStateValueStub




!!s/r m_slFluxGradientWindStub - Testing stub for FluxGradient routine, for wind
subroutine m_slFluxGradientWindStub(nss,dudz,dvdz,angtop,angmax, &
                                    utop,vtop,ztop,z0,ilmo,h,lat,n)
!!$subroutine m_slFluxGradientWindStub( &
!!$                             r_ft, r_dtdz, r_y_dtdz, r_angleTop, r_angleMax, &
!!$                             r_stateIn  (:,:,n_indexSurface_plus1), &
!!$                             r_y_stateIn(:,:,n_indexSurface_plus1), &
!!$                             r_zSrc     (:,:,n_indexSurface_plus1), &
!!$                             r_z0_a, &
!!$                             r_ilmo_a, &
!!$                             r_hBound_a, &
!!$                             r_latitude_a, &
!!$                             n_ni*n_nj)
!
!AUTHOR
!     Y. Delage    OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - extracted from the physics library
!
!OBJECT
!        To fill the role, in part, of the physics library during testing.  The
!        routine is copied here so as to keep this test independent of changes in
!        the physics library.
!
!        Calculates the surface stress and the slopes of the wind component
!        profiles at the top of the surface layer (SL)
!
!ARGUMENTS
      IMPLICIT NONE
      INTEGER N
      REAL NSS(N),DUDZ(N),DVDZ(N),ANGTOP(N), &
           UTOP(N),VTOP(N),ZTOP(N),Z0(N),ILMO(N),H(N),LAT(N)
      REAL ANGMAX

!          - Output -
! NSS     normalised surface stress
! DUDZ    slope of the U component of wind profile at top of SL
! DVDZ    slope of the V component of wind profile at top of SL
! ANGTOP  wind direction at top of SL
! ANGMAX  maximum wind direction change between surface and H
!
!          - Input -
! UTOP    U component of wind at the top of surface layer
! VTOP    V component of wind at the top of surface layer
! ZTOP    height of the top of the surface layer
! Z0      roughness length for wind
! ILMO    inverse of MONIN-OBUKHOV lenth
! H       height of boundary layer (for stable case only)
! LAT     latitude in radians
! N       number of horizontal points to process
!
!NOTES
!        This routine was supplied from the physics library by Yves Delage, who
!        called it sltop_uv, and put together by J.W. Blezius.
!
!!

      INTEGER J
      
      REAL      FM(N)
      REAL AS,ASX,CI,BS,BETA,FACTN,HMIN,SPEED

! Initilisation of constants in the common SURFCON
!
! Note: some of the constants may be reinitialised at runtime using a namelist

      AS    = 12.
      ASX   = 13.
      CI    = 40.
      BS    = 1.0
      BETA  = 1.0
      FACTN = 1.2
      HMIN  = 40.
      ANGMAX= 0.85

      call m_slStateValueWindStub(fm,ztop,z0,ilmo,h,n)
      DO J=1,N
        speed=sqrt(utop(j)**2+vtop(j)**2)
        angtop(j)=atan2(vtop(j),sign(abs(utop(j))+1.e-05,utop(j)))
        nss(j)=speed/fm(j)
        dudz(j)=nss(j)*phim(ztop(j),ilmo(j),h(j))*cos(angtop(j)) &
                              /(ztop(j)+z0(j)) &
                + speed*sin(angtop(j))*angmax*sin(lat(j))/h(j)
        dvdz(j)=nss(j)*phim(ztop(j),ilmo(j),h(j))*sin(angtop(j)) &
                              /(ztop(j)+z0(j)) &
                - speed*cos(angtop(j))*angmax*sin(lat(j))/h(j)
      END DO

      return
      CONTAINS
!  Derivatives of the stability functions

        REAL FUNCTION PHIM(Z,ILMO,H)

        REAL Z,ILMO,H,HH

        HH=MAX(1-Z/H,FACTN-1.0)
        IF(ILMO.GT.0.) THEN
           PHIM=MIN(1.+ASX*BETA*Z*ILMO,0.5*(HH+SQRT(HH**2+ &
                4.*AS*BETA*Z*ILMO*HH)))
        ELSE
           PHIM=(1.-CI*BETA*Z*ILMO)**(-.1666666)
        END IF
        RETURN
        END FUNCTION

        REAL FUNCTION PHIH(Z,ILMO,H)

        REAL Z,ILMO,H,HH

        HH=MAX(1-Z/H,FACTN-1.0)
        IF(ILMO.GT.0.) THEN
           PHIH=BETA*MIN(1.+ASX*BETA*Z*ILMO,0.5*(HH+SQRT(HH**2+ &
                4.*AS*BETA*Z*ILMO*HH)))
        ELSE
           PHIH=(1.-CI*BETA*Z*ILMO)**(-.333333333)
        END IF
        RETURN
        END FUNCTION
end subroutine m_slFluxGradientWindStub








!!s/r m_slStateValueWindStub - Testing stub for the StateValue routine for wind
subroutine m_slStateValueWindStub(fm,z,z0,ilmo,h,n)
!subroutine m_slStateValueWindStub(f, vLevelDestn(:,vt), z0, ilmo, hBound, &
!                                  numInterpSets)
!
!AUTHOR
!     Y. Delage    OCT 2003
!
!REVISION
! v1_3    Blezius J.W. OCT 2003 - extracted from the physics library
!
!OBJECT
!        To fill the role, in part, of the physics library during testing.  The
!        routine is copied here so as to keep this test independent of changes in
!        the physics library.
!
!        Calculates the integrated surface-layer functions for interpolating
!        wind speed.
!
!ARGUMENTS
      IMPLICIT NONE
      INTEGER N
      REAL FM(N),Z(N),Z0(N),ILMO(N),H(N)
!
!          - Output -
! FM      normalised wind speed at desired output height
!
!          - Input -
! Z       height of desired output
! Z0      roughness length for wind
! ILMO    inverse of MONIN-OBUKHOV lenth
! H       height of boundary layer (for stable case only)
! N       number of horizontal points to process
!
!NOTES
!        This routine was supplied from the physics library by Yves Delage, who
!        called it slfun_uv, and put together by J.W. Blezius.
!
!!
      INTEGER J
      REAL AS,ASX,CI,BS,BETA,FACTN,HMIN,ANGMAX

      REAL RAC3,X,X0,Y,Y0,Z0T(1),HI,LZZ0T(1)
      
      REAL      LZZ0(N)

! Initilisation of constants in the common SURFCON
!
! Note: some of the constants may be reinitialised at runtime using a namelist

      AS    = 12.
      ASX   = 13.
      CI    = 40.
      BS    = 1.0
      BETA  = 1.0
      FACTN = 1.2
      HMIN  = 40.
      ANGMAX= 0.85

      RAC3=SQRT(3.)
      DO J=1,N
      LZZ0(J)=LOG(Z(J)/Z0(J)+1)
      IF(ILMO(J).LE.0.) THEN
!---------------------------------------------------------------------
!                      UNSTABLE CASE
           fm(j)= fmi(z(j)+z0(j),j)
      ELSE
!---------------------------------------------------------------------
!                        STABLE CASE
        hi=1/MAX(H(J),hmin,factn/(4*AS*BETA*ilmo(j)), &
             (Z(J)+10*Z0(J))*factn)
        fm(j)=LZZ0(J)+min(psi(Z(J)+Z0(J),j)-psi(Z0(J),j), &
                           ASX*BETA*ILMO(J)*Z(J))
      ENDIF
!---------------------------------------------------------------------
      END DO

      return
      CONTAINS
!   Internal function FMI
!   Stability function for momentum in the unstable regime (ilmo<0)
!   Reference: Delage Y. and Girard C. BLM 58 (19-31) Eq. 19

      REAL FUNCTION FMI(Z,I)

      REAL Z
      integer i

      X=(1-CI*Z*BETA*ILMO(I))**(0.1666666)
      X0=(1-CI*Z0(I)*BETA*ILMO(I))**(0.1666666)
      FMI=LZZ0(I)+LOG((X0+1)**2*SQRT(X0**2-X0+1)*(X0**2+X0+1)**1.5 &
                     /((X+1)**2*SQRT(X**2-X+1)*(X**2+X+1)**1.5)) &
                    +RAC3*ATAN(RAC3*((X**2-1)*X0-(X0**2-1)*X)/ &
                    ((X0**2-1)*(X**2-1)+3*X*X0))

      RETURN
      END FUNCTION
!   Internal function FHI
!   Stability function for heat and moisture in the unstable regime (ilmo<0)
!   Reference: Delage Y. and Girard C. BLM 58 (19-31) Eq. 17

      REAL FUNCTION FHI(Z,I)

      REAL Z
      integer i

      Y=(1-CI*Z*BETA*ILMO(I))**(0.33333333)
      Y0=(1-CI*Z0T(I)*BETA*ILMO(I))**(0.3333333)
      FHI=BETA*(LZZ0T(I)+1.5*LOG((Y0**2+Y0+1)/(Y**2+Y+1))+RAC3* &
              ATAN(RAC3*2*(Y-Y0)/((2*Y0+1)*(2*Y+1)+3)))

      RETURN
      END FUNCTION
!   Internal function psi
!   Stability function for momentum in the stable regime (unsl>0)
!   Reference :  Y. Delage, BLM, 82 (p23-48) (Eqs.33-37)


      REAL FUNCTION PSI(Z,I)

      REAL Z,a,b,c,d
      integer i

      d = 4*AS*BETA*ilmo(i)
      c = d*hi - hi**2
      b = d - 2*hi
      a = sqrt(1 + b*z - c*z**2)
      psi = 0.5 * (a-z*hi-log(1+b*z*0.5+a)- &
                  b/(2*sqrt(c))*asin((b-2*c*z)/d))

      RETURN
      END FUNCTION
end subroutine m_slStateValueWindStub
