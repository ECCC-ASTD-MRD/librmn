*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
***S/P QLXOPR APPLIQUER UN OPERATEUR NUMERIQUE OU LOGIQUE
      SUBROUTINE QLXOPR(TOKENS,NTOKEN,TOKTYPE,OPRTR,ERR)
      INTEGER NTOKEN,OPRTR,TOKENS(NTOKEN),TOKTYPE(NTOKEN)
      LOGICAL ERR


*      EXTERNAL QLXMAD
*      INTEGER  QLXMAD
      INTEGER IZ1, IZ2, IR1
      REAL     Z1,  Z2,  R1
      EQUIVALENCE (IZ1,Z1),(IZ2,Z2),(IR1,R1)
      LOGICAL REALOP
      POINTER (PTOK,TOK(*))


#if defined (NEC) && defined (_FLOAT0)
     stop 'QLXOPR not available on NEC in 64bit pointer mode'
#endif

     IF(ERR) RETURN


      IF(OPRTR.EQ.4 .OR. OPRTR.EQ.17)
         MINOPER = 1
      ELSE
         MINOPER = 2


      IF(NTOKEN.LT.MINOPER) $(
         ERR = .TRUE.
         RETURN
         $)


      IF(TOKTYPE(NTOKEN).GT.0) $(        # 1ERE OPERANDE NUMERIQUE
         PEEK(TOKENS(NTOKEN),1,TOKENS(NTOKEN))
         TOKTYPE(NTOKEN) = 0
         $)


      IF(OPRTR.NE.2 .AND. OPRTR.NE.17       _
         .AND. OPRTR.NE.21 .AND. OPRTR.NE.4) $(   # 2 OPERANDES NUM.
         IF(TOKTYPE(NTOKEN-1).GT.0) $(        # ADRESSE
            PEEK(TOKENS(NTOKEN-1),1,TOKENS(NTOKEN-1))
            TOKTYPE(NTOKEN-1) = 0
            $)
         $)


      REALOP = ABS(TOKENS(NTOKEN)).GT.MAXINT
      IZ1 = TOKENS(NTOKEN)
      IF(OPRTR.NE.2 .AND. OPRTR.NE.17 .AND. OPRTR.NE.4) $(   # 2 OPERANDES NUM.
         REALOP = REALOP .OR. ABS(TOKENS(NTOKEN-1)).GT.MAXINT
         IZ2 = TOKENS(NTOKEN-1)
         IF(REALOP) $(
            IF(ABS(IZ1).LE.MAXINT) Z1 = TOKENS(NTOKEN)
            IF(ABS(IZ2).LE.MAXINT) Z2 = TOKENS(NTOKEN-1)
            $)
         $)


      IR1 = 0
      GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)OPRTR
1     ERR = .TRUE.
      RETURN


2     IF(TOKENS(NTOKEN).LE.0 .OR. TOKTYPE(NTOKEN-1).LE.0 .OR. REALOP) $(
         ERR = .TRUE.
         RETURN
         $)
      IF(TOKENS(NTOKEN).GE.TOKTYPE(NTOKEN-1)) $(
         ERR = .TRUE.
         RETURN
         $)
*temporaire      TOKENS(NTOKEN-1)=QLXMAD(TOKENS(NTOKEN-1),TOKENS(NTOKEN))
      PTOK = LOC(TOKENS(NTOKEN-1))
      TOKENS(NTOKEN-1) = TOK(TOKENS(NTOKEN))	
      NTOKEN = NTOKEN - 1
      TOKTYPE(NTOKEN) = 1                    # NO FURTHER INDEXING ALLOWED
      RETURN


3     RETURN      # UNARY +


4     IF(REALOP)
         R1 = -Z1
      ELSE
         IR1 = -IZ1
      GOTO 1000


5     IF(REALOP)
         R1 = Z2**Z1
      ELSE
         IR1 = IZ2**IZ1
      GOTO 1000


6     IF(REALOP)
         R1 = Z2*Z1
      ELSE
         IR1 = IZ2*IZ1
      GOTO 1000


7     IF(REALOP)
         R1 = Z2/Z1
      ELSE
         IR1 = IZ2/IZ1
      GOTO 1000


8     IF(REALOP)
         R1 = Z2+Z1
      ELSE
         IR1 = IZ2+IZ1
      GOTO 1000


9     IF(REALOP)
         R1 = Z2-Z1
      ELSE
         IR1 = IZ2-IZ1
      GOTO 1000


10    IF(REALOP) $(
         IF(Z2<Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


11    IF(REALOP) $(
         IF(Z2>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


12    IF(REALOP) $(
         IF(Z2==Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2==IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


13    IF(REALOP) $(
         IF(Z2<=Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<=IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


14    IF(REALOP) $(
         IF(Z2>=Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2>=IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


15    IF(REALOP) $(
         IF(Z2<>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


16    IF(REALOP) $(
         IF(Z2<>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000


17    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = COMPL(IZ1)
      GOTO 1000


18    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IAND(IZ2,IZ1)
      GOTO 1000


19    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IOR(IZ2,IZ1)
      GOTO 1000


20    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IEOR(IZ2,IZ1)
      GOTO 1000


21    IF(TOKTYPE(NTOKEN-1).LE.0) $(          # ASSIGNATION =
         ERR = .TRUE.
         RETURN
         $)
      POKE(TOKENS(NTOKEN-1),1,TOKENS(NTOKEN))
      NTOKEN = NTOKEN - 1
      RETURN


1000  NTOKEN = NTOKEN + 1 - MINOPER
      TOKENS(NTOKEN) = IR1
      TOKTYPE(NTOKEN) = 0
      RETURN
      END
