*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
***S/P QLXASG ASSIGNATION D'UNE OU PLUSIEURS VALEURS
      SUBROUTINE QLXASG(VAL,ICOUNT,LIMIT,ERR)
      INTEGER ICOUNT,LIMIT,VAL
      LOGICAL ERR
*
*OBJET(QLXASG)
*        PREND LES TOKENS QUI SUIVENT LE SIGNE  =  ET SEPARES PAR DES VIRGULES
*        POUR LES PLACER A L'ADRESSE VAL. ICOUNT EST LE NOMBRE DE MOTS DEPOSES
*ARGUMENTS
* E      VAL     ADRESSE DE LA CLE CIBLE
* E      ICOUNT  NOMBRE DE MOTS DEPOSES
* E      LIMIT   NOMBRE MAXIMAL DE MOTS DISPONIBLES
* S      ERR     INDICATEUR D'ERREUR
*
*IMPLICITES
#include "bufftok.cdk"
#include "qlxfmt.cdk"
**
      INTEGER IND,JLEN,QLXVAL
      INTEGER OLDTYP,ITEMP(80),IREPCN
      REAL TEMP(80)
      EQUIVALENCE (TEMP,ITEMP)
      LOGICAL IAREP,FIN
*
      IND=1
      OLDTYP=OPER
      FIN=.FALSE.
      IAREP=.FALSE.
      IREPCN=1
      JLEN=0
      CALL QLXIND(IND,ERR)
*
      IF(.NOT.ERR) CALL QLXTOK
      IF(TOKEN(1:2).EQ.'= ' .AND. TYPE.EQ.OPER .AND. .NOT. ERR)  $(
         WHILE(.NOT.ERR .AND. .NOT.FIN)  $(
            CALL QLXTOK
            IF ((TYPE == OPER) .AND. (TOKEN(1:1) == LPAREN))
              $(
                CALL QLXXPR(ERR)
                IF(ERR) BREAK
              $)
            IF(TYPE.EQ.ADRESSE)
               PEEK(JVAL,1,JVAL)


            ELSE IF(TYPE.EQ.ENTIER .AND. OLDTYP.EQ.OPER)  # NOMBRE ENTIER
             $(
              ITEMP(1)=JVAL
              JLEN=1
             $)
*
            ELSE IF(TYPE.EQ.REEL .AND. OLDTYP.EQ.OPER)  $(  # NOMBRE REEL
               TEMP(1)=ZVAL
               JLEN=1
               $)
*
            ELSE IF(TYPE.EQ.STRING .AND. OLDTYP.EQ.OPER)  $( # QUOTED STRING
               JLEN=(LEN+KARMOT-1)/KARMOT
               READ(TOKEN,LINEFMT)(ITEMP(J),J=1,JLEN)
#if !defined (ALL64)
101            FORMAT(20A4)
#else
101            FORMAT(10A8)
#endif
               $)
*
            ELSE IF(TYPE.EQ.OPER)  $(
           IF(TOKEN(1:2).EQ.'% ')  $(     # % PREFIXE DE REPETITION
                  IF(OLDTYP.EQ.ENTIER .AND.(.NOT.IAREP))  $(
                     IREPCN=ITEMP(1)
                     IF(IREPCN.GT.0)  $(
                        IAREP=.TRUE.
                        JLEN=0
                        $)
                     ELSE $(
                        CALL QLXERR(21001,'QLXASG')
                        ERR=.TRUE.
                        $)
                     $)
                  ELSE $(
                     CALL QLXERR(21002,'QLXASG')
                     ERR=.TRUE.
                     $)
                  $)
*
               ELSE IF(TOKEN(1:2).EQ.', ' .OR.TOKEN(1:2).EQ.'$ ') $( #,$ STORE
                  IF((IREPCN*MAX(JLEN,1)+IND).GT.LIMIT+1)  $(  # TOO BIG ?
                     CALL QLXERR(21003,'QLXASG')
                     ERR=.TRUE.
                     $)
                  ELSE $(                                   # NO, STORE IT
                     DO  I=1,IREPCN  $(
                        DO  J=1,JLEN  $(
                           POKE(VAL,IND+J-1,ITEMP(J))
                           $)
                        IND=IND+MAX(JLEN,1)
                        $)
                     IREPCN=1
                     IAREP=.FALSE.
                     JLEN=0
                     ICOUNT = IND-1
                    $)
                      FIN=TOKEN(1:1).EQ.'$'
                      $)
                   ELSE $(
                      CALL QLXERR(21004,'QLXASG')
                      ERR=.TRUE.
                      $)
                   $)
*
            ELSE IF(TYPE.EQ.CLE .AND. OLDTYP.EQ.OPER)  $(
               JLEN=1
               ITEMP(1)=QLXVAL(TOKEN(1:8),ERR)
               $)
            ELSE $(
               CALL QLXERR(21005,'QLXASG')
               ERR=.TRUE.
               $)
            OLDTYP=TYPE
            $)
         $)
*
      ELSE $(
         CALL QLXERR(21006,'QLXASG')
         ERR=.TRUE.
         $)
*
      RETURN
      END
