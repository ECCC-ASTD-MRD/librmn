*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
***S/P QLXINX DECLARATION DES ROUTINES
*
      SUBROUTINE QLXINX(XTERN,KEY,ICOUNT,LIMITS,ITYP)
      EXTERNAL XTERN
      INTEGER ITYP,LIMITS
      INTPOINT ICOUNT
      CHARACTER *(*) KEY
*
      INTEGER IDUM
*
      IF (ITYP <> 2)
        $(
           PRINT *,' *** QLXINX ne peut etre utilise pour ityp <> 2'
           CALL QLXERR(81013,'QLXINS')
           STOP
        $)
      CALL QQLXINS(IDUM,KEY,ICOUNT,LIMITS,ITYP,XTERN)
      RETURN
      END

***S/P QLXINS DECLARATION DES CLES
*
      SUBROUTINE QLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP)
      INTPOINT IVAR,ICOUNT
      INTEGER ITYP,LIMITS
      CHARACTER *(*) KEY
*
      EXTERNAL READLX
*
      IF (ITYP == 2)
        $(
           PRINT *,' *** QLXINX doit etre utilise quand ityp = 2',
                   ' au lieu de QLXINS'
           CALL QLXERR(81013,'QLXINS')
           STOP
*           PRINT *,' *** QLXINX doit etre utilise quand ityp = 2',
*                   ' au lieu de QLXINS'
*           CALL QLXERR(10013,'QLXINS')
*           CALL QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,IVAR)
        $)
      ELSE
        CALL QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,READLX)
      RETURN
      END

***S/P QQLXINS DECLARATION DES CLES ET DE LEUR TYPE
*
      SUBROUTINE QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,XTERN)
      INTPOINT IVAR,ICOUNT
      EXTERNAL XTERN
      INTEGER ITYP,LIMITS
      CHARACTER *(*) KEY
*
*        CONSTRUIT UNE TABLE CONTENANT LA CLE(IKEY), L'ADRESSE DES
*        VALEURS IVAR(MAXIMUM DE 'LIMITS')ET DU NOMBRE DE VALEURS(ICOUNT),
*        LE NOMBRE MAXIMUM DE VALEURS,ET LE TYPE DE SYMBOLES.
*
**
*
*     TABLES STATIQUES CONTENANT LES CLES, LEURS ADRESSES, ET LES LIMITES
*
      CHARACTER *8 IKEY
      INTEGER ITAB(3:3,MAXNTRY),NENTRY,IPNT
      INTPOINT IPTADR(2,MAXNTRY),loc_sub
      CHARACTER *8 NAMES(MAXNTRY)
      SAVE NAMES, ITAB, NENTRY, IPTADR
      DATA ITAB /MAXNTRY * 0/
      DATA IPTADR /MAXNTRY * 0, MAXNTRY * 0/
      DATA NAMES /MAXNTRY * ' '/
      DATA NENTRY /0/
*
*     TROUVER LA CLE
*


      CALL LOW2UP(KEY,IKEY)
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT.EQ.0)  $(
         NENTRY=NENTRY+1
         IPNT=NENTRY
         $)
*
      IF(IPNT.EQ.MAXNTRY)   $(
         CALL QLXERR(10011,'QLXINS')
         $)
*
      IF(LIMITS.LT.0 .OR. LIMITS.GT.99999)  $(
         CALL QLXERR(20012,'QLXINS')
         RETURN
         $)
*
      IF(ITYP.LT.0 .OR.ITYP.GT.13)  $(
         CALL QLXERR(20013,'QLXINS')
         RETURN
         $)
*
      ICOUNT=0
      NAMES(IPNT)=IKEY
      IF (ITYP == 2)
        IPTADR(1,IPNT)=loc_sub(XTERN)
      ELSE
        IPTADR(1,IPNT)=MEMADR(IVAR)
      ITAB(3,IPNT)=IOR(LIMITS,LSHIFT(ITYP,24))
      IPTADR(2,IPNT)=MEMADR(ICOUNT)
      RETURN
*
      ENTRY QLXLOOK(IVAR,KEY,ICOUNT,LIMITS,ITYP)  # FIND A KEY
*
*     TROUVER LA CLE
*
      CALL LOW2UP(KEY,IKEY)
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT == 0) $(
         ITYP = -1
         IVAR = 0
         ICOUNT = 0
         LIMITS = 0
         RETURN
         $)
*
*     DECORTIQUER LES PARAMETRES DE LA CLE
*
      IVAR=IPTADR(1,IPNT)
      ICOUNT=IPTADR(2,IPNT)
      LIMITS=IAND(ITAB(3,IPNT),RMASK(24))
      ITYP=RSHIFT(ITAB(3,IPNT),24)
      RETURN
*
      ENTRY QLXUDF(IVAR,KEY)           #  UNDEFINE A KEY
*
*     TROUVER LA CLE
*
      IKEY = KEY
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT .EQ. 0) RETURN     # NOTHING TO UNDEFINE


      DO I=IPNT, NENTRY-1   $(
         IPTADR(1,I) = IPTADR(1,I+1)
         ITAB(3,I) = ITAB(3,I+1)
         IPTADR(2,I) = IPTADR(2,I+1)
         NAMES(I)  = NAMES(I+1)
         $)
      NENTRY = NENTRY - 1


      RETURN
      ENTRY QLXDTB                # DUMP SYMBOL TABLE
      PRINT *,' NAMES, LOCVAR, TYPE/LIMITS, LOCCOUNT'
      DO I=1,NENTRY
         PRINT 101, NAMES(I),IPTADR(1,I),ITAB(3,I),IPTADR(2,I)
101   FORMAT (2X,A8,3Z22)
      RETURN
      END
