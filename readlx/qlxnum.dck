*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
***FONCTION QLXNUM    RECONSTITUER UN NOMBRE ENTIER, REEL OU OCTAL
      FUNCTION QLXNUM(IB,LENG)
      INTEGER QLXNUM
      CHARACTER *(*) IB
      INTEGER LENG
*
*
*AUTEUR     M.VALIN    RPN    JUIN 1983
*
*OBJET(QLXNUM)
*        A PARTIR D'UN TOKEN COMMENCANT PAR UN CHIFFRE, RECONSTITUER
*        LE NOMBRE. INDIQUER S'IL EST ENTIER OU REEL.
*ARGUMENT
*        QLXNUM    RETOURNE   -10   POUR UN NOMBRE REEL
*        (S)                   -9   POUR UN NOMBRE ENTIER
*                               -3   ERREUR
*
*        IB(*)     IB(1) EST LE PREMIER CHIFFRE DU NOMBRE.
*       (E)        LA TABLE IB CONTIENT LE NOMBRE.
*
*        LENG      NOMBRE DE CARACTERES DANS LE NOMBRE(ENTIER OU REEL)
*        (S)
**
      INTEGER ILX
      EXTERNAL QLXCHR
      CHARACTER *1 I, CTMP, QLXCHR
*
      IF(IB(1:1).EQ.PERIOD)  $(
         ILX=1
         $)
      ELSE  $(
         ILX=0
         $)
      I=QLXCHR()
*
      WHILE(I.GE.DIG0 .AND. I.LE.DIG9 ) $(
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         $)
*
      IF(I.EQ.PERIOD .AND. IB(1:1).NE.PERIOD) $(
         ILX=1
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         WHILE(I.GE.DIG0 .AND. I.LE.DIG9) $(
            LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=I
            I=QLXCHR()
            $)
         $)
*
      IF(I.EQ.LETE ) $(
         IF(ILX.EQ.0) $(
            LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=PERIOD
            $)
         ILX=1
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         IF((I.GE.DIG0 .AND. I.LE.DIG9).OR.(I.EQ.PLUS) _
           .OR.(I.EQ.MINUS))  $(
6           LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=I
            I=QLXCHR()
            IF(I.GE.DIG0 .AND. I.LE.DIG9) GOTO 6
            $)
         $)              #RAPAILLAGE TERMINE
*
      IF(LENG.GE.MAXDIG) $(
         QLXNUM=PASBON
         $)
*
      ELSE IF(ILX.EQ.0) $(
         IF(I.NE.LETB) $(
            QLXNUM=ENTIER
            $)
         ELSE  $(
            QLXNUM=OCTAL
            I=QLXCHR()
            DO  J=LENG,1,-1  $(     # ALIGNER A DROITE
               IF(IB(J:J).GT.DIG7)QLXNUM=PASBON     # VALIDATION
               CTMP = IB(J:J)
               IB(20-LENG+J:20-LENG+J)=CTMP
               $)
            DO  J=1,20-LENG  $(
               IB(J:J)=DIG0
               $)
            LENG=20
            $)
         $)
*
      ELSE IF(LENG.GT.1) $(
         IF(IB(LENG:LENG).EQ.PERIOD)
            QLXNUM=REEL
         ELSE IF(IB(LENG:LENG).GE.DIG0 .AND. IB(LENG:LENG).LE.DIG9)
            QLXNUM=REEL
         ELSE
            QLXNUM=PASBON
         $)
      ELSE
            QLXNUM=PASBON
      CALL QLXBAK(I)
*
      RETURN
      END
