*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
      SUBROUTINE QLXCALL(SUB,ICOUNT,LIMITS,ERR)
      INTPOINT SUB,ICOUNT
*
#include "bufftok.cdk"
*
#include "parmadr.cdk"
#include "qlxfmt.cdk"
*
      EXTERNAL RMTCALL, QLXADR, QLXVAL
      INTEGER  RMTCALL, QLXVAL
      INTEGER LIM1,LIM2,JLEN,PREVI
      INTPOINT LOCDUM, QLXADR
      CHARACTER *8 KLE
*
      LOGICAL ERR,FIN,INLIST
*
      DATA ADR  /41*0/
      DATA PARM /101*0/
*
      FIN  = .FALSE.
      INLIST = .FALSE.
      LOCDUM = MEMADR(PARM(1))
      NDOPES = 0
      DO I = 1,41
        $(
          DOPE(I) = 0
          DOPEA(I) = 0
          ADR(I) = LOCDUM
        $)
      NARG = 0
      NPRM = 0
      NPRM0 = 0
      PREVI = OPER
*
      CALL QLXTOK
      IF (TYPE.NE.OPER .AND. TOKEN(1:1).NE.LPAREN)  $(
         CALL QLXERR(81018,'QLXCALL')
         ERR = .TRUE.
         $)
*
      WHILE (.NOT. ERR .AND. .NOT.FIN)  $(
         CALL QLXTOK
         IF (PREVI .EQ. OPER)  $(
            IF (TYPE .EQ. CLE)  $(
               KLE = TOKEN(1:8)
               PREVI = OPERANDE
               IF(INLIST)$(
                  NPRM = MIN(NPRM+1,101)
                  PARM(NPRM) = QLXVAL(KLE,ERR)
                  $)
               ELSE $(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = QLXADR(KLE,ERR)
 	          DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM - 1
                  $)
               NDOPES = MIN(NDOPES+1,101)
	       DOPES(NDOPES) = TYPE + 1 * 256 + (NPRM-NPRM0)*256 *256
               DOPE(NARG) = DOPE(NARG) + 1
               $)
*
            ELSE IF (TYPE.EQ.ENTIER .OR. TYPE.EQ.REEL)  $(
               NPRM = MIN(NPRM+1,101)
               PARM(NPRM) = JVAL
               PREVI = OPERANDE
               IF(.NOT. INLIST) $(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = MEMADR(PARM(NPRM))
                  DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM - 1
                  $)
               NDOPES = MIN(NDOPES+1,101)
               DOPES(NDOPES) = TYPE + 1 * 256 + (NPRM-NPRM0)*256 *256
               DOPE(NARG) = DOPE(NARG) + 1
               $)
*
            ELSE IF (TYPE .EQ. STRING)  $(
               JLEN = MIN((LEN+KARMOT-1) / KARMOT , 101 - NPRM)
               IF(.NOT. INLIST)$(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = MEMADR(PARM(NPRM+1))
                  DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM
                  $)
               READ(TOKEN,LINEFMT) (PARM(J+NPRM),J=1,JLEN)
101            FORMAT(25 A CARMOT)
               NDOPES = MIN(NDOPES+1,101)
               DOPES(NDOPES) = TYPE + LEN * 256 + (NPRM-NPRM0+1)*256 *256
               NPRM = MIN(NPRM+JLEN,101)
*
               DOPE(NARG) = DOPE(NARG) + JLEN
               PREVI = OPERANDE
               $)
*
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.LBRAK .AND. .NOT.INLIST)$(
               INLIST = .TRUE.
               PREVI = OPER
               NARG = MIN(NARG+1,41)
               ADR(NARG) = MEMADR(PARM(NPRM+1))
               DOPEA(NARG) = NDOPES + 1
               NPRM0 = NPRM
               $)
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.RPAREN .AND. NARG.EQ.0)
               FIN = .TRUE.
            ELSE  $(
               CALL QLXERR(81019,'QLXCALL')
               ERR = .TRUE.
               $)
*
         $)  # FIN DU IF PREVI.EQ.OPER
*
         ELSE  $(
            IF (TYPE.EQ.OPER .AND. (TOKEN(1:1).EQ.COMMA .OR. TOKEN(1:1)_
                .EQ. RPAREN))  $(
               FIN = TOKEN(1:1).EQ.RPAREN
               PREVI = OPER
               $)
*
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.RBRAK .AND. INLIST)$(
               INLIST = .FALSE.
               $)
*
            ELSE  $(
               CALL QLXERR(81020,'QLXCALL')
               ERR = .TRUE.
               $)
*
            $)
*
         $)  # FIN DU WHILE
*
      DOPEA(NARG+1) = NDOPES + 1
      IF (.NOT. ERR)  $(
         LIM1 = LIMITS/100
         LIM2 = MOD(LIMITS,100)
         IF (NARG.GT.40 .OR. NPRM.GT.100 .OR. NDOPES .GT. 100)  $(
            CALL QLXERR(81021,'QLXCALL')
            ERR = .TRUE.
            $)
*
         ELSE IF (NARG.LT.LIM1 .OR. NARG.GT.LIM2)  $(
            CALL QLXERR(81022,'QLXCALL')
            ERR = .TRUE.
            $)
*
         ELSE  $(
            POKE(ICOUNT,1,NARG)
            JUNK=RMTCALL(SUB,ADR)
            POKE(ICOUNT,1,0)
            CALL QLXFLSH(DOLLAR)
            $)
*
         $)
*
      RETURN
      END
