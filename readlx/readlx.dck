*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
      SUBROUTINE READLX(UNIT,KEND,KERR)
*
***S/R READLX - INTERPRETE DE DIRECTIVES
*
*AUTEUR   - M. VALIN
*
*LANGAGE  - RATFOR
*
*APPEL    - CALL READLX(UNIT,KEND,KERR)
*
*MODULES  - QLXFND,QLXTOK,QLXASG,QLXCALL,QLXERR,QLXFLSH
*
*ARGUMENTS
*         - UNIT - UNITE D'ENTREE
*         - KEND - 0 = TOUT EST NORMAL
*                  ?
*
*         - KERR -
*
#include "bufftok.cdk"
#include "qlxbuff.cdk"
#include "qlxfmt.cdk"
**
      EXTERNAL QLXNVAR,QLXPRNT,QLXUNDF
      INTEGER UNIT,KEND,IVAR,ICOUNT
      INTPOINT LOCCNT,LOCVAR,IICNT
      INTEGER LIMITS,ITYP
      LOGICAL FIN,ERR
      PARAMETER (MAXSTRU=20)
      INTEGER NXTELSE(0:2), NEXTIF(0:2), STYPE(MAXSTRU), SKIPF(MAXSTRU)
      INTEGER READBSE(MAXSTRU)
      INTEGER NSTRUC,ier
      character * 128 nomscra
*
      DATA NXTELSE / 1, 0, 2/
      DATA NEXTIF  / 0, 2, 2/
*
      DATA KARMOT /CARMOT/
*
      WRITE(LINEFMT,'(A,I2,A)') '(25 A',KARMOT,')'
      KERRMAX = 999999
      IF(KERR.LT.0 ) KERRMAX = MIN(ABS(KERR),KERRMAX)
      NC=1
      LAST=0
      INPFILE=UNIT
      EOFL=.FALSE.
      NERR=0
      FIN=.FALSE.
      INEXPR=.FALSE.
      STYPE(1) = 0
      SKIPF(1) = 0
      NSTRUC = 1
      CURREC=0
      READREC=0
      READBSE(1)=0

      nomscra='XXXXQLX'
      tmpfile = 0
      ier = fnom(tmpfile,nomscra,'D77+SCRATCH+FMT',20)
      CALL QLXINX(QLXPRNT,'PRINT',IDUM,0202,2)
      CALL QLXINX(QLXNVAR,'DEFINE',IDUM,0202,2)
      CALL QLXINX(QLXUNDF,'UNDEF',IDUM,0101,2)
      WHILE(.NOT.FIN .AND. NERR.LT.KERRMAX .AND. NSTRUC.LT.MAXSTRU) $(
         SKIPFLG = SKIPF(NSTRUC)
         ERR=.FALSE.
         CALL QLXTOK
         IF(TYPE.EQ.CLE)  $(
            CALL QLXFND(TOKEN,LOCVAR,LOCCNT,LIMITS,ITYP)
            IF(ITYP.EQ.1 .AND. SKIPF(NSTRUC).EQ.0)  $(  # ASSIGNATION
               PEEK(LOCCNT,1,IICNT)
               CALL QLXASG(LOCVAR,IICNT,LIMITS,ERR)
               POKE(LOCCNT,1,IICNT)
               $)
            ELSE IF(ITYP.EQ.2 .AND. SKIPF(NSTRUC).EQ.0)  $(  # APPEL
               CALL QLXCALL(LOCVAR,LOCCNT,LIMITS,ERR)
               $)
            ELSE IF(ITYP.EQ.3)  $(                  # IF CONDITION
               NSTRUC = NSTRUC + 1
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NEXTIF(SKIPF(NSTRUC-1))
               IF(SKIPF(NSTRUC).EQ.0) $(            # NOT ALREADY SKIPPING
                  CALL QLXTOK
                  IF(TOKEN(1:1).NE.DOLLAR) $(
                     CALL QLXXPR(ERR)
                     IF(ERR) BREAK
                     IF(TYPE.EQ.ADRESSE)
                        PEEK(JVAL,1,JVAL)
                     IF(IAND(JVAL,MASK(16)).EQ.0)
                        SKIPF(NSTRUC) = 1
                     $)
                  ELSE
                     CALL QLXBAK(DOLLAR)
                  $)
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.4) $(                # ELSE
               IF(STYPE(NSTRUC).NE.3) BREAK
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NXTELSE(SKIPF(NSTRUC))
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.5) $(                # ENDIF
               IF(STYPE(NSTRUC).NE.3 .AND. STYPE(NSTRUC).NE.4) BREAK
               SKIPF(NSTRUC) = 0
               NSTRUC = NSTRUC - 1
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.6)  $(                  # WHILE STATEMENT
               NSTRUC = NSTRUC + 1
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NEXTIF(SKIPF(NSTRUC-1))
               IF (READREC <> 0)
                 READBSE(NSTRUC) = READREC -1
               ELSE
                 READBSE(NSTRUC) = CURREC
               IF(SKIPF(NSTRUC).EQ.0) $(            # NOT ALREADY SKIPPING
                  CALL QLXTOK
                  IF(TOKEN(1:1).NE.DOLLAR) $(
                     CALL QLXXPR(ERR)
                     IF(ERR) BREAK
                     IF(TYPE.EQ.ADRESSE)
                        PEEK(JVAL,1,JVAL)
                     IF(IAND(JVAL,MASK(16)).EQ.0)
                        SKIPF(NSTRUC) = 1
                     $)
                  ELSE
                     CALL QLXBAK(DOLLAR)
                  $)
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.7) $(                # ENDWHILE
               IF(STYPE(NSTRUC).NE.6) BREAK
               IF (SKIPF(NSTRUC) .EQ. 0)
                 READREC = READBSE(NSTRUC)
               SKIPF(NSTRUC) = 0
               NSTRUC = NSTRUC - 1
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.GE.10 .AND. ITYP.LE.13 .AND. SKIPF(NSTRUC).EQ.0)  $(
               KERR=NERR
               KEND=ITYP-10
               FIN=.TRUE.
               $)
            ELSE IF(SKIPF(NSTRUC).NE.0) $(
               CALL QLXFLSH(DOLLAR)       # SKIPPING... DO NOT EXECUTE
               $)
            ELSE  $(
               CALL QLXERR(21015,'READLX')
               ERR=.TRUE.
               $)
            $)
         ELSE  $(
            CALL QLXERR(21016,'READLX')
            ERR=.TRUE.
            $)
         IF(ERR.AND.(TOKEN(1:1).NE.DOLLAR.OR. TYPE.NE.OPER))  $(
            CALL QLXFLSH(DOLLAR)
            $)
         $)
      IF(NSTRUC.GT.1) $(
         WRITE(6,*)' ERREUR DANS LA STRUCTURE DES BLOCS IF THEN ELSE'
         KERR = NERR + 1
         KEND = -1
         $)
*
      CLOSE(TMPFILE,STATUS='DELETE')
      RETURN
      END

