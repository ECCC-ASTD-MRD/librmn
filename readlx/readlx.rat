* 
   DEFINE(BITMOT,32)
   DEFINE(CARMOT,04)                  # NOMBRE DE CARACTERES PAR MOT
   DEFINE(ENTMAX,VALU(B17777777777))  # ENTIER MAXIMUM (31 BITS)
   DEFINE(OCW   ,O11)       # FORMAT OCTAL POUR UN MOT
   DEFINE(IMPNONE,[IMPLICIT NONE])       # FORCER DECLARATIONS EN FORTRAN
   DEFINE(EXPBIAS,127)      # EXPONENT BIAS, POUR NORMALISATION
   DEFINE(BITCAR,08)                     # NOMBRE DE BITS PAR CARACTERE
   DEFINE(MEMADR,LOC)                    # FONCTION MEMORY ADDRESS
   DEFINE(CURTIM,CLOCK)                  # FONCTION HEURE COURANTE
   MACRO(OCT,[VALU(B%1)])   # GENERE UNE CONSTANTE OCTALE
   MACRO(HEX,[Z'%1'])       # GENERE UNE CONSTANTE HEXADECIMALE
   MACRO(HCAR,["%1"])       # GENERE LES CHAINES DE FORMAT H.
   MACRO(COMPL,[NOT(%1)])                # COMPLEMENT LOGIQUE
   MACRO(IXOR,[ieor(%1,%2)])
   MACRO(ixor,[ieor(%1,%2)])
   MACRO(MASK,[ishft(-1,BITMOT-(%1))])     # MASQUE A GAUCHE DE %1 BITS
   MACRO(RMASK,[ishft(-1,-(BITMOT-(%1)))]) # MASQUE A DROITE DE %1 BITS
   MACRO(RSHIFT,[ishft(%1,-(%2))])
   MACRO(RXSHIFT,[ishft(%1,-(%2))])                   # SHIFT A DROITE DE NBITS
   MACRO(RYSHIFT,[ishft(%1,-(%2))])
   MACRO(LXSHIFT,[ishft(%1,%2)]) # SHIFT A GAUCHE DE NBITS
   MACRO(LYSHIFT,[ishft(%1,%2)])
   MACRO(LSHIFT,[ishft(%1,%2)])
   MACRO(SHCNT,[(31-IAND(%1,31))])    # SHIFT COUNT POUR L'EXTRACTION DU BIT %1
   MACRO(XTRACBIT,[ibits(MOT,BDROIT,LONG)]) #EXTRAIRE UN CHAMP D'UN MOT
MACRO(WDNO,[(1+RSHIFT(%1,5))])    # NUMERO DU MOT CONTENANT LE BIT %1
*
*  MACRO ICHAMP(MOT,FIN,LG)   EXTRAIT UN CHAMP D'UN MOT
*
*   MOT   MOT QUI CONTIENT LE CHAMP
*   FIN   NUMERO DU DERNIER BIT (A DROITE) DU CHAMP, EN NUMEROTATION
*         GAUCHE > DROITE (LE BIT 0 EST A DROITE DU MOT).
*   LG    LONGUEUR, EN BITS, DU CHAMP
*
MACRO(ICHAMP,[RSHIFT( LSHIFT(%1, BITMOT-(%2)-(%3) ), BITMOT-(%3) )]);
*
*  MACRO IUNPAK(BASE, BITPOS, LG)  OBTENIR UN CHAMP D'UN TABLEAU
*
*  BASE    TABLEAU CONTENANT LE CHAMP A EXTRAIRE
*  BITPOS  POSITION DU BIT DE DROITE DU CHAMP A EXTRAIRE
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU.
*  LG      EST LE NOMBRE DE BITS QU'OCCUPE LE CHAMP. (MAX 32 BITS)
*
MACRO(IUNPAK,[ICHAMP(%1(1+(%2)/BITMOT),BITMOT-MOD(%2,BITMOT)-1,%3)]);
*
*
*  MACRO GETBIT(BASE, BITPOS, LG)  OBTENIR UN CHAMP D'UN TABLEAU
*
*  BASE    TABLEAU CONTENANT LE CHAMP A EXTRAIRE
*  BITPOS  POSITION DU BIT DE DROITE DU CHAMP A EXTRAIRE
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU.
*  LG      EST LE NOMBRE DE BITS QU'OCCUPE LE CHAMP. (MAX 32 BITS)
*
MACRO(GETBIT,[IAND(RSHIFT(%1(WDNO(%2)),SHCNT(%2)),RMASK(%3))])
*
*
*  MACRO INSERT(TABL,KWA,BITPOS,LONG)  INSERER UN CHAMP DANS UN TABLEAU
*
*  TABL    TABLEAU QUI CONTIENDRA LE CHAMP APRES INSERTION
*  KWA     MOT QUI CONTIENT LE CHAMP A INSERER JUSTIFIE A DROITE
*  BITPOS  POSITION DU DERNIER BIT (A DROITE) DU CHAMP A INSERER
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU
*  LONG    LONGUEUR EN BIT DU CHAMP A INSERER (PAS PLUS DE 32 BITS)
*
MACRO(INSERT,[%1(1+(%3)/BITMOT) = (%1(1+(%3)/BITMOT) & (.NOT. LSHIFT(_
 RMASK(%4),BITMOT-1-MOD(%3,BITMOT)))) ! LSHIFT(%2,BITMOT-1-MOD(%3,BITMOT))])
*
*  MACRO PUTBIT(TABL,KWA,BITPOS,LONG)  INSERER UN CHAMP DANS UN TABLEAU
*
*  TABL    TABLEAU QUI CONTIENDRA LE CHAMP APRES INSERTION
*  KWA     MOT QUI CONTIENT LE CHAMP A INSERER JUSTIFIE A DROITE
*  BITPOS  POSITION DU DERNIER BIT (A DROITE) DU CHAMP A INSERER
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU
*  LONG    LONGUEUR EN BIT DU CHAMP A INSERER (PAS PLUS DE 32 BITS)
*
MACRO(PUTBIT,[%1(WDNO(%3))=IOR(%1(WDNO(%3)),LSHIFT(IAND(%2,RMASK(%4)),
SHCNT(%3)))])
*
*  MACRO CLRBIT(TABL,BITPOS,LONG)  METTRE A ZERO UN CHAMP DANS UN TABLEAU
*
*  TABL    TABLEAU
*  BITPOS  POSITION DU DERNIER BIT (A DROITE) DU CHAMP A NETTOYER
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU
*  LONG    LONGUEUR EN BIT DU CHAMP A NETTOYER (PAS PLUS DE 32 BITS)
*
MACRO(CLRBIT,[%1(WDNO(%2))=IAND(%1(WDNO(%2)),
COMPL(LSHIFT(RMASK(%3),SHCNT(%2))))])
*
*  MACRO PUTBITC(TABL,KWA,BITPOS,LONG)  INSERER UN CHAMP DANS UN TABLEAU
*                                       AVEC NETTOYAGE PRELIMINAIRE
*  TABL    TABLEAU QUI CONTIENDRA LE CHAMP APRES INSERTION
*  KWA     MOT QUI CONTIENT LE CHAMP A INSERER JUSTIFIE A DROITE
*  BITPOS  POSITION DU DERNIER BIT (A DROITE) DU CHAMP A INSERER
*          LE BIT 0 EST LE BIT SIGNE DU PREMIER MOT DU TABLEAU
*  LONG    LONGUEUR EN BIT DU CHAMP A INSERER (PAS PLUS DE 32 BITS)
*
MACRO(PUTBITC,[CLRBIT(%1,%3,%4);PUTBIT(%1,%2,%3,%4)])
*.PAGE
   DEFINE (INTPOINT,Integer*8)
   MACRO(LPAREN,['('])
   MACRO(RPAREN,[')'])
   DEFINE (ATSIGN,'@')
   DEFINE (LETA,'A')
   DEFINE (LETB,'B')
   DEFINE (LETC,'C')
   DEFINE (LETD,'D')
   DEFINE (LETE,'E')
   DEFINE (LETF,'F')
   DEFINE (LETG,'G')
   DEFINE (LETH,'H')
   DEFINE (LETI,'I')
   DEFINE (LETJ,'J')
   DEFINE (LETK,'K')
   DEFINE (LETL,'L')
   DEFINE (LETM,'M')
   DEFINE (LETN,'N')
   DEFINE (LETO,'O')
   DEFINE (LETP,'P')
   DEFINE (LETQ,'Q')
   DEFINE (LETR,'R')
   DEFINE (LETS,'S')
   DEFINE (LETT,'T')
   DEFINE (LETU,'U')
   DEFINE (LETV,'V')
   DEFINE (LETW,'W')
   DEFINE (LETX,'X')
   DEFINE (LETY,'Y')
   DEFINE (LETZ,'Z')
   DEFINE (DIG0,'0')
   DEFINE (DIG1,'1')
   DEFINE (DIG2,'2')
   DEFINE (DIG3,'3')
   DEFINE (DIG4,'4')
   DEFINE (DIG5,'5')
   DEFINE (DIG6,'6')
   DEFINE (DIG7,'7')
   DEFINE (DIG8,'8')
   DEFINE (DIG9,'9')
   DEFINE (DOLLAR,'$')
   DEFINE (SQUOTE,'''')
   DEFINE (DQUOTE,'"')
   DEFINE (PERIOD,'.')
   DEFINE (COMMA,',')
   DEFINE (BLANK,' ')
   DEFINE (EQUAL,'=')
   DEFINE (PLUS,'+')
   DEFINE (MINUS,'-')
   DEFINE (LBRAK,'[')
   DEFINE (RBRAK,']')
   DEFINE (UNDER,'_')
   DEFINE (STAR,'*')
   DEFINE (SLASH,'/')
   DEFINE (PERCENT,'%')
   DEFINE (SHARP,'#')
   DEFINE (CLE,0)
   DEFINE (ENTIER,1)
   DEFINE (REEL,2)
   DEFINE (STRING,3)
   DEFINE (OPER,4)
   DEFINE (OPERANDE,7)
   DEFINE (PASBON,5)
   DEFINE (OCTAL,6)
   DEFINE (ADRESSE,8)
   DEFINE (MAXDIG,21)
   DEFINE (MAXNTRY,256)
   DEFINE (MAXTB,VALU(4*MAXNTRY))
   DEFINE (MAXTOK,81)
   DEFINE (MAXSCR,1024)
   DEFINE (MAXINT,VALU(B17777777777))
   DEFINE (CAR80,80)
   DEFINE (PEEK,CALLPEEK)
   DEFINE (POKE,CALLPOKE)
*.PAGE
* 
***FONCTION ARGDIMS LONGUEUR D'ARGUMENTS (APPEL VIA READLX)
*
      FUNCTION ARGDIMS(N)
      INTEGER ARGDIMS
      INTEGER N
*
*OBJET(ARGDIMS)
*         RENVOYER LA LONGUEUR EN NOMBRE DE MOTS DE L'ARGUMENT
*         N DU DERNIER APPEL EFFECTUE VIA READLX
*
*ARGUMENTS
* IN      N     NUMERO D'ORDRE DE L'ARGUMENT DANS LA LISTE
*
*IMPLICITES
      COMMON /PARMADR/NPRM,NARG,DOPE(41),PARM(101)
      COMMON /PARMADR/NDOPES,DOPEA(42),DOPES(101),ADR(41)
      INTEGER NARG,NPRM,DOPE,NDOPE,DOPEA,DOPES,PARM
      INTPOINT ADR
**
      IF(N .LE. NARG)
        ARGDIMS = DOPE(N)
      ELSE
        ARGDIMS = 0
      RETURN
      END
* 
***FONCTION ARGDOPE - GET DOPE LIST OF ARGUMENT NARG
*
      FUNCTION ARGDOPE(N,LISTE,ND)
      INTEGER ARGDOPE
      INTEGER N,ND
      INTEGER LISTE(ND)
*
*
*OBJET(ARGDOPE)
*      GET DOPE LIST OF ARGUMENT NARG
*
*AUTEUR
*     M. VALIN
*
*IMPLICITE
*
      COMMON /PARMADR/NPRM,NARG,DOPE(41),PARM(101)
      COMMON /PARMADR/NDOPES,DOPEA(42),DOPES(101),ADR(41)
      INTEGER NARG,NPRM,DOPE,NDOPE,DOPEA,DOPES,PARM
      INTPOINT ADR
*
**
      INTEGER I,BASE
      IF (N > NARG)
        ARGDOPE = 0
      ELSE
        $(
          BASE = DOPEA(N)
          ARGDOPE = DOPEA(N+1) - DOPEA(N)
          DO I = 1,MIN(DOPEA(N+1)-DOPEA(N),ND)
             LISTE(I) = DOPES(BASE+I-1)
        $)
      RETURN
      END
* 
***S/P LEXINS  -  INTERFACE DE QLXINS
*
      SUBROUTINE LEXINS(IVAR,ICLE,NB,LIMIT,TYP)
      INTEGER IVAR,ICLE,NB,LIMIT,TYP
*
*AUTEUR M. LEPINE  -  OCT 89
*
*OBJET(LEXINS)
*     INTERFACE ENTRE L'ANCIENNE ROUTINE LEXINS ET LA NOUVELLE
*     QLXINS
**
      CHARACTER * 8 KLE
*
      WRITE(KLE,'(A8)') ICLE
      CALL QLXINS(IVAR,KLE,NB,LIMIT,TYP)
      RETURN
      END
* 
***S/P QLXADI GET VALUE OF INDEXED ARRAY COMPONENT
      SUBROUTINE QLXADI(KLE,IND,VALEUR,TYPE,ERR)
      INTEGER IND,VALEUR,TYPE
      LOGICAL ERR
      CHARACTER *(*) KLE
**
      INTEGER  QLXDTYP
      EXTERNAL QLXDTYP
      INTPOINT LOCVAR,LOCCNT
      INTEGER LIMITE,ITYP,IZ,INDX
      REAL Z
      EQUIVALENCE(Z,IZ)
      IZ = IND
      IF(QLXDTYP(IZ).EQ.ENTIER)
         INDX = IZ
      ELSE
         INDX = NINT(Z)
      CALL QLXFND(KLE,LOCVAR,LOCCNT,LIMITE,ITYP)
      IF(ITYP.NE.0 .AND. ITYP.NE.1) ERR = .TRUE.
      IF(INDX.GT.LIMITE .OR. INDX.LE.0) ERR = .TRUE.
      IF(.NOT.ERR)$(
         PEEK(LOCVAR,INDX,VALEUR)
         $)
      RETURN
      END
* 
**S/P GET SUBSCRIPT THEN BUILD MACHINE ADDRESS
      INTPOINT FUNCTION QLXADR(KLE,ERR)
*
      CHARACTER *(*) KLE
      LOGICAL ERR
      INTEGER LIMITS,INF,ITYP
      INTPOINT LOCCNT
      POINTER (LOCVAR,VARI(*))
**
      CALL QLXIND(IND,ERR)
*
      IF(.NOT. ERR)  $(
         CALL QLXFND(KLE,LOCVAR,LOCCNT,LIMITS,ITYP)
         IF(IND.LE.LIMITS .AND. ITYP.GE.0 .AND. ITYP.LE.1) $(
*            QLXADR = QLXMAD(LOCVAR,IND)
	     QLXADR = LOC(VARI(IND))
            $)
         ELSE  $(
            ERR=.TRUE.
            CALL QLXERR(21017,'QLXADR')
            QLXADR=0
            $)
         $)
*
      ELSE  $(
         QLXADR=0
         $)
*
      RETURN
      END
* 
***S/P QLXASG ASSIGNATION D'UNE OU PLUSIEURS VALEURS
      SUBROUTINE QLXASG(VAL,ICOUNT,LIMIT,ERR)
      INTEGER ICOUNT,LIMIT,VAL
      LOGICAL ERR
*
*OBJET(QLXASG)
*        PREND LES TOKENS QUI SUIVENT LE SIGNE  =  ET SEPARES PAR DES VIRGULES
*        POUR LES PLACER A L'ADRESSE VAL. ICOUNT EST LE NOMBRE DE MOTS DEPOSES
*ARGUMENTS
* E      VAL     ADRESSE DE LA CLE CIBLE
* E      ICOUNT  NOMBRE DE MOTS DEPOSES
* E      LIMIT   NOMBRE MAXIMAL DE MOTS DISPONIBLES
* S      ERR     INDICATEUR D'ERREUR
*
*IMPLICITES
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
**
      INTEGER IND,JLEN,QLXVAL
      INTEGER OLDTYP,ITEMP(80),IREPCN
      REAL TEMP(80)
      EQUIVALENCE (TEMP,ITEMP)
      LOGICAL IAREP,FIN
*
      IND=1
      OLDTYP=OPER
      FIN=.FALSE.
      IAREP=.FALSE.
      IREPCN=1
      JLEN=0
      CALL QLXIND(IND,ERR)
*
      IF(.NOT.ERR) CALL QLXTOK
      IF(TOKEN(1:2).EQ.'= ' .AND. TYPE.EQ.OPER .AND. .NOT. ERR)  $(
         WHILE(.NOT.ERR .AND. .NOT.FIN)  $(
            CALL QLXTOK
            IF ((TYPE == OPER) .AND. (TOKEN(1:1) == LPAREN))
              $(
                CALL QLXXPR(ERR)
                IF(ERR) BREAK
              $)
            IF(TYPE.EQ.ADRESSE)
               PEEK(JVAL,1,JVAL)
            ELSE IF(TYPE.EQ.ENTIER .AND. OLDTYP.EQ.OPER)  # NOMBRE ENTIER
             $(
              ITEMP(1)=JVAL
              JLEN=1
             $)
*
            ELSE IF(TYPE.EQ.REEL .AND. OLDTYP.EQ.OPER)  $(  # NOMBRE REEL
               TEMP(1)=ZVAL
               JLEN=1
               $)
*
            ELSE IF(TYPE.EQ.STRING .AND. OLDTYP.EQ.OPER)  $( # QUOTED STRING
               JLEN=(LEN+KARMOT-1)/KARMOT
               READ(TOKEN,LINEFMT)(ITEMP(J),J=1,JLEN)
101            FORMAT(20A4)
               $)
*
            ELSE IF(TYPE.EQ.OPER)  $(
           IF(TOKEN(1:2).EQ.'% ')  $(     # % PREFIXE DE REPETITION
                  IF(OLDTYP.EQ.ENTIER .AND.(.NOT.IAREP))  $(
                     IREPCN=ITEMP(1)
                     IF(IREPCN.GT.0)  $(
                        IAREP=.TRUE.
                        JLEN=0
                        $)
                     ELSE $(
                        CALL QLXERR(21001,'QLXASG')
                        ERR=.TRUE.
                        $)
                     $)
                  ELSE $(
                     CALL QLXERR(21002,'QLXASG')
                     ERR=.TRUE.
                     $)
                  $)
*
               ELSE IF(TOKEN(1:2).EQ.', ' .OR.TOKEN(1:2).EQ.'$ ') $( #,$ STORE
                  IF((IREPCN*MAX(JLEN,1)+IND).GT.LIMIT+1)  $(  # TOO BIG ?
                     CALL QLXERR(21003,'QLXASG')
                     ERR=.TRUE.
                     $)
                  ELSE $(                                   # NO, STORE IT
                     DO  I=1,IREPCN  $(
                        DO  J=1,JLEN  $(
                           POKE(VAL,IND+J-1,ITEMP(J))
                           $)
                        IND=IND+MAX(JLEN,1)
                        $)
                     IREPCN=1
                     IAREP=.FALSE.
                     JLEN=0
                     ICOUNT = IND-1
                    $)
                      FIN=TOKEN(1:1).EQ.'$'
                      $)
                   ELSE $(
                      CALL QLXERR(21004,'QLXASG')
                      ERR=.TRUE.
                      $)
                   $)
*
            ELSE IF(TYPE.EQ.CLE .AND. OLDTYP.EQ.OPER)  $(
               JLEN=1
               ITEMP(1)=QLXVAL(TOKEN(1:8),ERR)
               $)
            ELSE $(
               CALL QLXERR(21005,'QLXASG')
               ERR=.TRUE.
               $)
            OLDTYP=TYPE
            $)
         $)
*
      ELSE $(
         CALL QLXERR(21006,'QLXASG')
         ERR=.TRUE.
         $)
*
      RETURN
      END
* 
***S/P QLXBAK     RENVOYER UN CARACTERE
      SUBROUTINE QLXBAK(ICAR)
      CHARACTER *1 ICAR
*
*
*AUTEUR   M. VALIN  RPN  JUIN 1983
*
*OBJET(QLXBAK)
*        QLXBAK REMET UN CARACTERE DANS UNE LIGNE DE TEXTE,
*        A LA POSITION COURANTE. IL RECULE EN CONSEQUENCE LE
*        POINTEUR DU CARACTERE COURANT
*ARGUMENT
*        ICAR      CARACTERE(1 CARACTERE HOLLERITH) RENVOYE DANS LA LIGNE DE TEX
*         E
*
      COMMON /QLXBUFF/ NC,LAST,INPFILE,EOFL,NERR,SKIPFLG
      COMMON /QLXBUFF/ CURREC,READREC,TMPFILE
      INTEGER NC,LAST,INPFILE,NERR,SKIPFLG,CURREC,READREC,TMPFILE
      LOGICAL EOFL
      COMMON /QLXBUF2/ INLINE
      CHARACTER *101 INLINE
**
      IF(NC.GT.1)  $(
         INLINE(NC-1:NC-1)=ICAR
         NC=NC-1
         $)
      ELSE
         CALL QLXERR(81007,'QLXBAK')
*
      RETURN
      END
* 
      SUBROUTINE QLXCALL(SUB,ICOUNT,LIMITS,ERR)
      INTPOINT SUB,ICOUNT
*
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
*
      COMMON /PARMADR/NPRM,NARG,DOPE(41),PARM(101)
      COMMON /PARMADR/NDOPES,DOPEA(42),DOPES(101),ADR(41)
      INTEGER NARG,NPRM,DOPE,NDOPE,DOPEA,DOPES,PARM
      INTPOINT ADR
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
*
      EXTERNAL RMTCALL, QLXADR, QLXVAL
      INTEGER  RMTCALL, QLXVAL
      INTEGER LIM1,LIM2,JLEN,PREVI
      INTPOINT LOCDUM, QLXADR
      CHARACTER *8 KLE
*
      LOGICAL ERR,FIN,INLIST
*
      DATA ADR  /41*0/
      DATA PARM /101*0/
*
      FIN  = .FALSE.
      INLIST = .FALSE.
      LOCDUM = MEMADR(PARM(1))
      NDOPES = 0
      DO I = 1,41
        $(
          DOPE(I) = 0
          DOPEA(I) = 0
          ADR(I) = LOCDUM
        $)
      NARG = 0
      NPRM = 0
      NPRM0 = 0
      PREVI = OPER
*
      CALL QLXTOK
      IF (TYPE.NE.OPER .AND. TOKEN(1:1).NE.LPAREN)  $(
         CALL QLXERR(81018,'QLXCALL')
         ERR = .TRUE.
         $)
*
      WHILE (.NOT. ERR .AND. .NOT.FIN)  $(
         CALL QLXTOK
         IF (PREVI .EQ. OPER)  $(
            IF (TYPE .EQ. CLE)  $(
               KLE = TOKEN(1:8)
               PREVI = OPERANDE
               IF(INLIST)$(
                  NPRM = MIN(NPRM+1,101)
                  PARM(NPRM) = QLXVAL(KLE,ERR)
                  $)
               ELSE $(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = QLXADR(KLE,ERR)
 	          DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM - 1
                  $)
               NDOPES = MIN(NDOPES+1,101)
	       DOPES(NDOPES) = TYPE + 1 * 256 + (NPRM-NPRM0)*256 *256
               DOPE(NARG) = DOPE(NARG) + 1
               $)
*
            ELSE IF (TYPE.EQ.ENTIER .OR. TYPE.EQ.REEL)  $(
               NPRM = MIN(NPRM+1,101)
               PARM(NPRM) = JVAL
               PREVI = OPERANDE
               IF(.NOT. INLIST) $(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = MEMADR(PARM(NPRM))
                  DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM - 1
                  $)
               NDOPES = MIN(NDOPES+1,101)
               DOPES(NDOPES) = TYPE + 1 * 256 + (NPRM-NPRM0)*256 *256
               DOPE(NARG) = DOPE(NARG) + 1
               $)
*
            ELSE IF (TYPE .EQ. STRING)  $(
               JLEN = MIN((LEN+KARMOT-1) / KARMOT , 101 - NPRM)
               IF(.NOT. INLIST)$(
                  NARG = MIN(NARG+1,41)
                  ADR(NARG) = MEMADR(PARM(NPRM+1))
                  DOPEA(NARG) = NDOPES + 1
                  NPRM0 = NPRM
                  $)
               READ(TOKEN,LINEFMT) (PARM(J+NPRM),J=1,JLEN)
101            FORMAT(25 A CARMOT)
               NDOPES = MIN(NDOPES+1,101)
               DOPES(NDOPES) = TYPE + LEN * 256 + (NPRM-NPRM0+1)*256 *256
               NPRM = MIN(NPRM+JLEN,101)
*
               DOPE(NARG) = DOPE(NARG) + JLEN
               PREVI = OPERANDE
               $)
*
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.LBRAK .AND. .NOT.INLIST)$(
               INLIST = .TRUE.
               PREVI = OPER
               NARG = MIN(NARG+1,41)
               ADR(NARG) = MEMADR(PARM(NPRM+1))
               DOPEA(NARG) = NDOPES + 1
               NPRM0 = NPRM
               $)
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.RPAREN .AND. NARG.EQ.0)
               FIN = .TRUE.
            ELSE  $(
               CALL QLXERR(81019,'QLXCALL')
               ERR = .TRUE.
               $)
*
         $)  # FIN DU IF PREVI.EQ.OPER
*
         ELSE  $(
            IF (TYPE.EQ.OPER .AND. (TOKEN(1:1).EQ.COMMA .OR. TOKEN(1:1)_
                .EQ. RPAREN))  $(
               FIN = TOKEN(1:1).EQ.RPAREN
               PREVI = OPER
               $)
*
            ELSE IF(TYPE.EQ.OPER .AND. TOKEN(1:1).EQ.RBRAK .AND. INLIST)$(
               INLIST = .FALSE.
               $)
*
            ELSE  $(
               CALL QLXERR(81020,'QLXCALL')
               ERR = .TRUE.
               $)
*
            $)
*
         $)  # FIN DU WHILE
*
      DOPEA(NARG+1) = NDOPES + 1
      IF (.NOT. ERR)  $(
         LIM1 = LIMITS/100
         LIM2 = MOD(LIMITS,100)
         IF (NARG.GT.40 .OR. NPRM.GT.100 .OR. NDOPES .GT. 100)  $(
            CALL QLXERR(81021,'QLXCALL')
            ERR = .TRUE.
            $)
*
         ELSE IF (NARG.LT.LIM1 .OR. NARG.GT.LIM2)  $(
            CALL QLXERR(81022,'QLXCALL')
            ERR = .TRUE.
            $)
*
         ELSE  $(
            POKE(ICOUNT,1,NARG)
            JUNK=RMTCALL(SUB,ADR)
            POKE(ICOUNT,1,0)
            CALL QLXFLSH(DOLLAR)
            $)
*
         $)
*
      RETURN
      END
* 
***FONCTION QLXCHR     RETOURNE UN CARACTERE A LA FOIS D'UNE LIGNE
      FUNCTION QLXCHR()
      CHARACTER *1 QLXCHR
*
*
*AUTEUR M.VALIN  RPN  JUIN 1983
*
*OBJET(QLXCHR)
*        RETOURNE UN CARACTERE D'UNE LIGNE DE TEXTE,
*        ET AVANCE LE POINTEUR D'UNE POSITION.
*ARGUMENT
*        QLXCHR    CARACTERE RENVOYE(1 CARACTERE HOLLERITH)
*      S
*
      COMMON /QLXBUFF/ NC,LAST,INPFILE,EOFL,NERR,SKIPFLG
      COMMON /QLXBUFF/ CURREC,READREC,TMPFILE
      INTEGER NC,LAST,INPFILE,NERR,SKIPFLG,CURREC,READREC,TMPFILE
      LOGICAL EOFL
      COMMON /QLXBUF2/ INLINE
      CHARACTER *101 INLINE
*
      CHARACTER *8 SKIPMSG(0:3)
      LOGICAL COMMENT
      INTEGER PRTFLAG
      DATA SKIPMSG/'<<    >>','<<SKIP>>','<<SKIP>>','<< ** >>'/
      DATA NC,LAST/1,0/
      DATA INPFILE/5/
      DATA EOFL/.FALSE./
      DATA INLINE/' '/
*
      IF(NC.LE.LAST)  $(
         QLXCHR=INLINE(NC:NC)
         NC=NC+1
         $)
*
      ELSE IF (.NOT. EOFL)   $(
1        CONTINUE
         IF(READREC.GT.CURREC) READREC=0
         IF(READREC.EQ.0) $(
            READ(INPFILE,'(A80)',END=10)INLINE(21:100)
            CURREC = CURREC + 1
            WRITE(TMPFILE,'(A80)',REC=CURREC)INLINE(21:100)
            $)
         ELSE $(
            READ(TMPFILE,'(A80)',REC=READREC)INLINE(21:100)
            READREC = READREC + 1
            $)
         INLINE(1:20) = ' '
         COMMENT = .FALSE.
         PRTFLAG = SKIPFLG
         IF (INLINE(21:21).EQ.LETC .OR. INLINE(21:21).EQ.STAR .OR.
             INLINE(21:21) .EQ. SHARP)
           IF (PRTFLAG == 0)
             $(
               COMMENT = .TRUE.
               PRTFLAG=3
             $)
           ELSE
             COMMENT = .TRUE.
         WRITE(6,'(1X,A8,1X,A80)') _
              SKIPMSG(PRTFLAG),INLINE(21:100)
         IF ((INLINE.EQ.BLANK) .OR. (COMMENT)) GOTO 1  # LIGNE BLANCHE
         LAST=100
         WHILE(LAST.GT.21 .AND.INLINE(LAST:LAST).EQ.BLANK) $(
            LAST=LAST-1
            $)
         IF (INLINE(LAST:LAST) .EQ. UNDER) # CONTINUATION
            LAST = LAST-1
         ELSE IF (INLINE(LAST:LAST) .NE. COMMA)  $(
            LAST = LAST+1
            INLINE(LAST:LAST) = DOLLAR    # LIGNE COMPLETE, AJOUTE DOLLAR
            $)
         QLXCHR=INLINE(21:21)
         NC=22
         $)
*
      ELSE $(
         CALL QLXERR(81008,'QLXCHR')
         CALL ABORT
         $)
*
      RETURN
10    INLINE = ' END$'
      QLXCHR=' '
      EOFL=.TRUE.
      LAST=5
      NC=2
*
      RETURN
      END
* 
      SUBROUTINE QLXDBG
      COMMON /QLXBUFF/ NC,LAST,INPFILE,EOFL,NERR,SKIPFLG
      COMMON /QLXBUFF/ CURREC,READREC,TMPFILE
      INTEGER NC,LAST,INPFILE,NERR,SKIPFLG,CURREC,READREC,TMPFILE
      LOGICAL EOFL
      COMMON /QLXBUF2/ INLINE
      CHARACTER *101 INLINE
      WRITE(6,*) 'NC=',NC,'LAST=',LAST,'INPFILE=',INPFILE
      WRITE(6,'(1X,A101)')INLINE(1:101)
*
      RETURN
      END
* 
***FUNCTION QLXDTYP  TYPE OF A DATA ITEM
      FUNCTION QLXDTYP(ITEM)
      INTEGER QLXDTYP
      INTEGER ITEM
      IF(ABS(ITEM).LE.MAXINT)
         QLXDTYP = ENTIER
      ELSE
         QLXDTYP = REEL
      RETURN
      END
* 
***S/P QLXERR     IMPRIME DES MESSAGES D'ERREUR
      SUBROUTINE QLXERR(CODE,MODULE)
      INTEGER CODE
      CHARACTER *(*) MODULE
*
*
*AUTEUR  M.VALIN  RPN  JUIN 1983
*
*OBJET
*        IMPRIME LE NOM DU MODULE DANS LEQUEL UNE ERREUR EST DETECTEE,
*        LE TYPE D'ERREUR, ET LE MESSAGE D'ERREUR APPROPRIE. SI L'ERREUR
*        EST FATALE, IL FAIT UN ABORT.
*ARGUMENTS
*        CODE
*        MODULE    DE TYPE CARACTERE. DESIGNE LE MODULE DANS LEQUEL L'ERREUR  ES
*
      COMMON /QLXBUFF/ NC,LAST,INPFILE,EOFL,NERR,SKIPFLG
      COMMON /QLXBUFF/ CURREC,READREC,TMPFILE
      INTEGER NC,LAST,INPFILE,NERR,SKIPFLG,CURREC,READREC,TMPFILE
      LOGICAL EOFL
      COMMON /QLXBUF2/ INLINE
      CHARACTER *101 INLINE
**
      INTEGER DESTI,MT,ME
      CHARACTER *80 ERMSG
      CHARACTER *7 TYPE(9)
      CHARACTER *40 MSG(50)
      DATA MSG(  1) /'REPETITION NEGATIF'/
      DATA MSG(  2) /'NB DE FOIS DEJA VU OU NON ENTIER'/
      DATA MSG(  3) /'LA LIMITE EST DEPASSEE'/
      DATA MSG(  4) /'OPERATEUR MAL PLACE'/
      DATA MSG(  5) /'TOKEN MAL PLACE'/
      DATA MSG(  6) /'IL MANQUE LE SIGNE EGAL'/
      DATA MSG(  7) /'DEBORDEMENT DU TAMPON D ENTREE'/
      DATA MSG(  8) /'FIN DU FICHIER DEPASSEE'/
      DATA MSG(  9) /'INDICE NEGATIF, NUL OU NON ENTIER'/
      DATA MSG( 10) /'MANQUE LE CROCHET DROIT'/
      DATA MSG( 11) /'TABLE DES SYMBOLES PLEINE'/
      DATA MSG( 12) /'LIMITE > 99999'/
      DATA MSG( 13) /'MAUVAIS CODE DE TYPE'/
      DATA MSG( 14) /'TOKEN DOUTEUX'/
      DATA MSG( 15) /'CLE MAL UTILISEE'/
      DATA MSG( 16) /'PAS TROUVE LA CLE'/
      DATA MSG( 17) /'INDICE HORS LIMITE OU MAUVAISE CLE'/
      DATA MSG( 18) /'( ATTENDU'/
      DATA MSG( 19) /'OPERANDE DEMANDEE'/
      DATA MSG( 20) /', OU ) ATTENDU'/
      DATA MSG( 21) /'LA PILE D ARGUMENTS DEBORDE'/
      DATA MSG( 22) /'TROP OU PAS ASSEZ D''ARGUMENTS'/
*
      DATA TYPE( 1) /'INFO'/
      DATA TYPE( 2) /'TRIVIAL'/
      DATA TYPE( 3) /'       '/
      DATA TYPE( 4) /'       '/
      DATA TYPE( 5) /'       '/
      DATA TYPE( 6) /'       '/
      DATA TYPE( 7) /'       '/
      DATA TYPE( 8) /'FATAL'/
      DATA TYPE( 9) /'SYSTEME'/
*
      MT = CODE / 10000
      NERR = NERR + 1
      ME = MOD(CODE,1000)
      DESTI = MOD(CODE/1000,10)
*
      WRITE(ERMSG,600) ME,MODULE,TYPE(MT),MSG(ME)
  600 FORMAT(' RLX',I3.3,'-',A7,'-',A7,'-',A40)
*
      WRITE(6,*) ERMSG
      WRITE(6,'(1X,A)') INLINE(21:LAST)
      WRITE(6,'(1X,101A1)') (' ',I=1,NC-22),'^'
*
      RETURN
      END
* 
***S/P QLXFLSH     RETIENT  UN SEUL CARACTERE D'UNE LIGNE.
      SUBROUTINE QLXFLSH(ICAR)
      CHARACTER *1 ICAR
*
*AUTEUR M. VALIN  RPN  JUIN 1983
*
*
*OBJET
*        RETOURNE LE PREMIER CARACTERE D'UNE LIGNE DE TEXTE,
*        QUI SOIT EGAL A L'ARGUMENT.
*ARGUMENT
*        ICAR     ENTIER SERVANT D'ARGUMENT D'ENTREE . IL DESIGNE
*                 LE CARACTERE A ETRE RETENU DANS LA LIGNE DE TEXTE.
**
      EXTERNAL QLXCHR
      CHARACTER *1 QLXCHR
*
      WHILE(QLXCHR()<>ICAR) ;
*
      RETURN
      END
* 
      SUBROUTINE QLXFND(KEY,LOCVAR,LOCCNT,LIMITS,ITYP)
      INTPOINT LOCVAR,LOCCNT,loc_sub
      INTEGER LIMITS,ITYP
      CHARACTER *(*) KEY
*
*        RETROUVE, A PARTIR DE LA CLE IKEY, L'ADRESSE DE IVAR,ICOUNT.
*
      INTEGER QLXNVAR, QLXUNDF, QLXPRNT
      EXTERNAL QLXNVAR, QLXUNDF, QLXPRNT, LOW2UP
      CHARACTER *8 IKEY, CLEF(12)
      INTEGER DUMMY,IPNT,POS
      SAVE DUMMY
      DATA CLEF /'END','IF','ELSE','ENDIF','WHILE','ENDWHILE','ENDDATA',
                 'ENDCASE','ENDREAD','@PRINT','@DEFINE','@UNDEF'/
*
      LOCVAR=0
      LOCCNT=0
      LIMITS=0
      ITYP=-1
      CALL LOW2UP(KEY,IKEY)
*
      POS = 0
      DO I = 1,12
        IF (IKEY == CLEF(I)) 
          $(
             POS = I
             GOTO 05
          $)
 05   CONTINUE
      GOTO (10,20,30,40,50,60,70,80,90,100,110,120,130) POS+1
 10   CONTINUE
      CALL QLXLOOK(LOCVAR,IKEY,LOCCNT,LIMITS,ITYP)
      GOTO 200
 20   CONTINUE     
         ITYP = 10
      GOTO 200
 30   CONTINUE
         ITYP = 3
      GOTO 200
 40   CONTINUE
         ITYP = 4
      GOTO 200
 50   CONTINUE
         ITYP = 5
      GOTO 200
 60   CONTINUE
         ITYP = 6
      GOTO 200
 70   CONTINUE
         ITYP = 7
      GOTO 200
 80   CONTINUE
         ITYP = 11
      GOTO 200
 90   CONTINUE
         ITYP = 12
      GOTO 200
 100  CONTINUE
         ITYP = 13
      GOTO 200
 110  CONTINUE
         ITYP = 2
         LOCVAR = LOC_SUB(QLXPRNT)
         LOCCNT = MEMADR(DUMMY)
         LIMITS = 202
      GOTO 200
 120  CONTINUE
         ITYP = 2
         LOCVAR = LOC_SUB(QLXNVAR)
         LOCCNT = MEMADR(DUMMY)
         LIMITS = 202
      GOTO 200
 130  CONTINUE
         ITYP = 2
         LOCVAR = LOC_SUB(QLXUNDF)
         LOCCNT = MEMADR(DUMMY)
         LIMITS = 101
 200  CONTINUE
      RETURN
      END
* 
      SUBROUTINE QLXIND(IND,ERR)
*
*
      INTEGER IND
      LOGICAL ERR
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
**
      EXTERNAL QLXSKP
      CHARACTER *1 QLXSKP
      CHARACTER *1 IC
      IND=1
      IC=QLXSKP(BLANK)
*
      IF(IC.EQ.LBRAK)  $(
         CALL QLXTOK
         IF(((TYPE.EQ.ENTIER) .OR.(TYPE.EQ.CLE)) .AND. JVAL.GT.0)
            IND=JVAL
         ELSE  $(
            CALL QLXERR(21009,'QLXIND')
            ERR=.TRUE.
            $)
         IF(.NOT.ERR)  $(
            CALL QLXTOK
            IF(TOKEN(1:1).NE.RBRAK .OR. TYPE.NE.OPER)  $(
               CALL QLXERR(21010,'QLXIND')
               ERR=.TRUE.
               $)
            $)
         $)
*
      ELSE
         CALL QLXBAK(IC)
*
      RETURN
      END
* 
***S/P QLXINX DECLARATION DES ROUTINES
*
      SUBROUTINE QLXINX(XTERN,KEY,ICOUNT,LIMITS,ITYP)
      EXTERNAL XTERN
      INTEGER ITYP,LIMITS
      INTPOINT ICOUNT
      CHARACTER *(*) KEY
*
      INTEGER IDUM
*
      IF (ITYP <> 2)
        $(
           PRINT *,' *** QLXINX ne peut etre utilise pour ityp <> 2'
           CALL QLXERR(81013,'QLXINS')
           STOP
        $)
      CALL QQLXINS(IDUM,KEY,ICOUNT,LIMITS,ITYP,XTERN)
      RETURN
      END
***S/P QLXINS DECLARATION DES CLES
*
      SUBROUTINE QLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP)
      INTPOINT IVAR,ICOUNT
      INTEGER ITYP,LIMITS
      CHARACTER *(*) KEY
*
      EXTERNAL READLX
*
      IF (ITYP == 2)
        $(
           PRINT *,' *** QLXINX doit etre utilise quand ityp = 2',
                   ' au lieu de QLXINS'
           CALL QLXERR(81013,'QLXINS')
           STOP
*           PRINT *,' *** QLXINX doit etre utilise quand ityp = 2',
*                   ' au lieu de QLXINS'
*           CALL QLXERR(10013,'QLXINS')
*           CALL QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,IVAR)
        $)
      ELSE
        CALL QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,READLX)
      RETURN
      END
***S/P QQLXINS DECLARATION DES CLES ET DE LEUR TYPE
*
      SUBROUTINE QQLXINS(IVAR,KEY,ICOUNT,LIMITS,ITYP,XTERN)
      INTPOINT IVAR,ICOUNT
      EXTERNAL XTERN
      INTEGER ITYP,LIMITS
      CHARACTER *(*) KEY
*
*        CONSTRUIT UNE TABLE CONTENANT LA CLE(IKEY), L'ADRESSE DES
*        VALEURS IVAR(MAXIMUM DE 'LIMITS')ET DU NOMBRE DE VALEURS(ICOUNT),
*        LE NOMBRE MAXIMUM DE VALEURS,ET LE TYPE DE SYMBOLES.
*
**
*
*     TABLES STATIQUES CONTENANT LES CLES, LEURS ADRESSES, ET LES LIMITES
*
      CHARACTER *8 IKEY
      INTEGER ITAB(3:3,MAXNTRY),NENTRY,IPNT
      INTPOINT IPTADR(2,MAXNTRY),loc_sub
      CHARACTER *8 NAMES(MAXNTRY)
      SAVE NAMES, ITAB, NENTRY, IPTADR
      DATA ITAB /MAXNTRY * 0/
      DATA IPTADR /MAXNTRY * 0, MAXNTRY * 0/
      DATA NAMES /MAXNTRY * ' '/
      DATA NENTRY /0/
*
*     TROUVER LA CLE
*
      CALL LOW2UP(KEY,IKEY)
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT.EQ.0)  $(
         NENTRY=NENTRY+1
         IPNT=NENTRY
         $)
*
      IF(IPNT.EQ.MAXNTRY)   $(
         CALL QLXERR(10011,'QLXINS')
         $)
*
      IF(LIMITS.LT.0 .OR. LIMITS.GT.99999)  $(
         CALL QLXERR(20012,'QLXINS')
         RETURN
         $)
*
      IF(ITYP.LT.0 .OR.ITYP.GT.13)  $(
         CALL QLXERR(20013,'QLXINS')
         RETURN
         $)
*
      ICOUNT=0
      NAMES(IPNT)=IKEY
      IF (ITYP == 2)
        IPTADR(1,IPNT)=loc_sub(XTERN)
      ELSE
        IPTADR(1,IPNT)=MEMADR(IVAR)
      ITAB(3,IPNT)=IOR(LIMITS,LSHIFT(ITYP,24))
      IPTADR(2,IPNT)=MEMADR(ICOUNT)
      RETURN
*
      ENTRY QLXLOOK(IVAR,KEY,ICOUNT,LIMITS,ITYP)  # FIND A KEY
*
*     TROUVER LA CLE
*
      CALL LOW2UP(KEY,IKEY)
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT == 0) $(
         ITYP = -1
         IVAR = 0
         ICOUNT = 0
         LIMITS = 0
         RETURN
         $)
*
*     DECORTIQUER LES PARAMETRES DE LA CLE
*
      IVAR=IPTADR(1,IPNT)
      ICOUNT=IPTADR(2,IPNT)
      LIMITS=IAND(ITAB(3,IPNT),RMASK(24))
      ITYP=RSHIFT(ITAB(3,IPNT),24)
      RETURN
*
      ENTRY QLXUDF(IVAR,KEY)           #  UNDEFINE A KEY
*
*     TROUVER LA CLE
*
      IKEY = KEY
      IPNT=NENTRY
      WHILE(IPNT > 0 .AND. IKEY<>NAMES(IPNT))
         IPNT = IPNT - 1
      IF(IPNT .EQ. 0) RETURN     # NOTHING TO UNDEFINE
      DO I=IPNT, NENTRY-1   $(
         IPTADR(1,I) = IPTADR(1,I+1)
         ITAB(3,I) = ITAB(3,I+1)
         IPTADR(2,I) = IPTADR(2,I+1)
         NAMES(I)  = NAMES(I+1)
         $)
      NENTRY = NENTRY - 1
      RETURN
      ENTRY QLXDTB                # DUMP SYMBOL TABLE
      PRINT *,' NAMES, LOCVAR, TYPE/LIMITS, LOCCOUNT'
      DO I=1,NENTRY
         PRINT 101, NAMES(I),IPTADR(1,I),ITAB(3,I),IPTADR(2,I)
101   FORMAT (2X,A8,3Z22)
      RETURN
      END
* 
***FONCTION QLXNUM    RECONSTITUER UN NOMBRE ENTIER, REEL OU OCTAL
      FUNCTION QLXNUM(IB,LENG)
      INTEGER QLXNUM
      CHARACTER *(*) IB
      INTEGER LENG
*
*
*AUTEUR     M.VALIN    RPN    JUIN 1983
*
*OBJET(QLXNUM)
*        A PARTIR D'UN TOKEN COMMENCANT PAR UN CHIFFRE, RECONSTITUER
*        LE NOMBRE. INDIQUER S'IL EST ENTIER OU REEL.
*ARGUMENT
*        QLXNUM    RETOURNE   -10   POUR UN NOMBRE REEL
*        (S)                   -9   POUR UN NOMBRE ENTIER
*                               -3   ERREUR
*
*        IB(*)     IB(1) EST LE PREMIER CHIFFRE DU NOMBRE.
*       (E)        LA TABLE IB CONTIENT LE NOMBRE.
*
*        LENG      NOMBRE DE CARACTERES DANS LE NOMBRE(ENTIER OU REEL)
*        (S)
**
      INTEGER ILX
      EXTERNAL QLXCHR
      CHARACTER *1 I, CTMP, QLXCHR
*
      IF(IB(1:1).EQ.PERIOD)  $(
         ILX=1
         $)
      ELSE  $(
         ILX=0
         $)
      I=QLXCHR()
*
      WHILE(I.GE.DIG0 .AND. I.LE.DIG9 ) $(
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         $)
*
      IF(I.EQ.PERIOD .AND. IB(1:1).NE.PERIOD) $(
         ILX=1
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         WHILE(I.GE.DIG0 .AND. I.LE.DIG9) $(
            LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=I
            I=QLXCHR()
            $)
         $)
*
      IF(I.EQ.LETE ) $(
         IF(ILX.EQ.0) $(
            LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=PERIOD
            $)
         ILX=1
         LENG=MIN(MAXDIG,LENG+1)
         IB(LENG:LENG)=I
         I=QLXCHR()
         IF((I.GE.DIG0 .AND. I.LE.DIG9).OR.(I.EQ.PLUS) _
           .OR.(I.EQ.MINUS))  $(
6           LENG=MIN(MAXDIG,LENG+1)
            IB(LENG:LENG)=I
            I=QLXCHR()
            IF(I.GE.DIG0 .AND. I.LE.DIG9) GOTO 6
            $)
         $)              #RAPAILLAGE TERMINE
*
      IF(LENG.GE.MAXDIG) $(
         QLXNUM=PASBON
         $)
*
      ELSE IF(ILX.EQ.0) $(
         IF(I.NE.LETB) $(
            QLXNUM=ENTIER
            $)
         ELSE  $(
            QLXNUM=OCTAL
            I=QLXCHR()
            DO  J=LENG,1,-1  $(     # ALIGNER A DROITE
               IF(IB(J:J).GT.DIG7)QLXNUM=PASBON     # VALIDATION
               CTMP = IB(J:J)
               IB(20-LENG+J:20-LENG+J)=CTMP
               $)
            DO  J=1,20-LENG  $(
               IB(J:J)=DIG0
               $)
            LENG=20
            $)
         $)
*
      ELSE IF(LENG.GT.1) $(
         IF(IB(LENG:LENG).EQ.PERIOD)
            QLXNUM=REEL
         ELSE IF(IB(LENG:LENG).GE.DIG0 .AND. IB(LENG:LENG).LE.DIG9)
            QLXNUM=REEL
         ELSE
            QLXNUM=PASBON
         $)
      ELSE
            QLXNUM=PASBON
      CALL QLXBAK(I)
*
      RETURN
      END
* 
      SUBROUTINE QLXNVAR(KEY,NW)
      INTEGER NW
      INTEGER KEY(*)
      EXTERNAL ARGDIMS
      INTEGER  ARGDIMS
      INTEGER SC(MAXSCR),NSC
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
      SAVE SC, NSC
      INTEGER DUMMY
      CHARACTER *8 IKEY
      SAVE DUMMY
      DATA NSC /1/
      DATA DUMMY /0/
      WRITE(IKEY,LINEFMT) (KEY(J),J=1,ARGDIMS(1))
101   FORMAT(2 A CARMOT)
      CALL QLXLOOK(IVAR,IKEY,ICOUNT,LIMITS,ITYP)
      IF(ITYP.NE.-1) RETURN
      IF(NSC+NW .GT. MAXSCR+1) $(
         CALL QLXERR(21011,'DEFINE')
         RETURN
         $)
      CALL QLXINS(SC(NSC),IKEY,DUMMY,NW,1)
      NSC = NSC + NW
      RETURN
      END
* 
***S/P QLXOPR APPLIQUER UN OPERATEUR NUMERIQUE OU LOGIQUE
      SUBROUTINE QLXOPR(TOKENS,NTOKEN,TOKTYPE,OPRTR,ERR)
      INTEGER NTOKEN,OPRTR,TOKENS(NTOKEN),TOKTYPE(NTOKEN)
      LOGICAL ERR
*      EXTERNAL QLXMAD
*      INTEGER  QLXMAD
      INTEGER IZ1, IZ2, IR1
      REAL     Z1,  Z2,  R1
      EQUIVALENCE (IZ1,Z1),(IZ2,Z2),(IR1,R1)
      LOGICAL REALOP
      POINTER (PTOK,TOK(*))
     IF(ERR) RETURN
      IF(OPRTR.EQ.4 .OR. OPRTR.EQ.17)
         MINOPER = 1
      ELSE
         MINOPER = 2
      IF(NTOKEN.LT.MINOPER) $(
         ERR = .TRUE.
         RETURN
         $)
      IF(TOKTYPE(NTOKEN).GT.0) $(        # 1ERE OPERANDE NUMERIQUE
         PEEK(TOKENS(NTOKEN),1,TOKENS(NTOKEN))
         TOKTYPE(NTOKEN) = 0
         $)
      IF(OPRTR.NE.2 .AND. OPRTR.NE.17       _
         .AND. OPRTR.NE.21 .AND. OPRTR.NE.4) $(   # 2 OPERANDES NUM.
         IF(TOKTYPE(NTOKEN-1).GT.0) $(        # ADRESSE
            PEEK(TOKENS(NTOKEN-1),1,TOKENS(NTOKEN-1))
            TOKTYPE(NTOKEN-1) = 0
            $)
         $)
      REALOP = ABS(TOKENS(NTOKEN)).GT.MAXINT
      IZ1 = TOKENS(NTOKEN)
      IF(OPRTR.NE.2 .AND. OPRTR.NE.17 .AND. OPRTR.NE.4) $(   # 2 OPERANDES NUM.
         REALOP = REALOP .OR. ABS(TOKENS(NTOKEN-1)).GT.MAXINT
         IZ2 = TOKENS(NTOKEN-1)
         IF(REALOP) $(
            IF(ABS(IZ1).LE.MAXINT) Z1 = TOKENS(NTOKEN)
            IF(ABS(IZ2).LE.MAXINT) Z2 = TOKENS(NTOKEN-1)
            $)
         $)
      IR1 = 0
      GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)OPRTR
1     ERR = .TRUE.
      RETURN
2     IF(TOKENS(NTOKEN).LE.0 .OR. TOKTYPE(NTOKEN-1).LE.0 .OR. REALOP) $(
         ERR = .TRUE.
         RETURN
         $)
      IF(TOKENS(NTOKEN).GE.TOKTYPE(NTOKEN-1)) $(
         ERR = .TRUE.
         RETURN
         $)
*temporaire      TOKENS(NTOKEN-1)=QLXMAD(TOKENS(NTOKEN-1),TOKENS(NTOKEN))
      PTOK = LOC(TOKENS(NTOKEN-1))
      TOKENS(NTOKEN-1) = TOK(TOKENS(NTOKEN))	
      NTOKEN = NTOKEN - 1
      TOKTYPE(NTOKEN) = 1                    # NO FURTHER INDEXING ALLOWED
      RETURN
3     RETURN      # UNARY +
4     IF(REALOP)
         R1 = -Z1
      ELSE
         IR1 = -IZ1
      GOTO 1000
5     IF(REALOP)
         R1 = Z2**Z1
      ELSE
         IR1 = IZ2**IZ1
      GOTO 1000
6     IF(REALOP)
         R1 = Z2*Z1
      ELSE
         IR1 = IZ2*IZ1
      GOTO 1000
7     IF(REALOP)
         R1 = Z2/Z1
      ELSE
         IR1 = IZ2/IZ1
      GOTO 1000
8     IF(REALOP)
         R1 = Z2+Z1
      ELSE
         IR1 = IZ2+IZ1
      GOTO 1000
9     IF(REALOP)
         R1 = Z2-Z1
      ELSE
         IR1 = IZ2-IZ1
      GOTO 1000
10    IF(REALOP) $(
         IF(Z2<Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
11    IF(REALOP) $(
         IF(Z2>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
12    IF(REALOP) $(
         IF(Z2==Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2==IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
13    IF(REALOP) $(
         IF(Z2<=Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<=IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
14    IF(REALOP) $(
         IF(Z2>=Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2>=IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
15    IF(REALOP) $(
         IF(Z2<>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
16    IF(REALOP) $(
         IF(Z2<>Z1) IR1 = MASK(BITMOT)
      $) ELSE $(
         IF(IZ2<>IZ1) IR1 = MASK(BITMOT)
         $)
      GOTO 1000
17    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = COMPL(IZ1)
      GOTO 1000
18    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IAND(IZ2,IZ1)
      GOTO 1000
19    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IOR(IZ2,IZ1)
      GOTO 1000
20    IF(REALOP)
         ERR = .TRUE.
      ELSE
         IR1 = IEOR(IZ2,IZ1)
      GOTO 1000
21    IF(TOKTYPE(NTOKEN-1).LE.0) $(          # ASSIGNATION =
         ERR = .TRUE.
         RETURN
         $)
      POKE(TOKENS(NTOKEN-1),1,TOKENS(NTOKEN))
      NTOKEN = NTOKEN - 1
      RETURN
1000  NTOKEN = NTOKEN + 1 - MINOPER
      TOKENS(NTOKEN) = IR1
      TOKTYPE(NTOKEN) = 0
      RETURN
      END
* 
***S/P QLXOPT  -  PASSAGE D'OPTIONS A READLX
*
      SUBROUTINE QLXOPT(OPTION,VAL)
      CHARACTER * (*) OPTION
      INTEGER VAL
*
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
*
      IF (OPTION(1:6) == 'CARMOT')
        $(
          KARMOT = VAL
          WRITE(LINEFMT,'(A,I2,A)') '(25 A',KARMOT,')'
        $)
      ELSE
        WRITE(6,*) ' *** ERREUR QLXOPT, OPTION (',OPTION,') INCONNUE'
      RETURN
      END
* 
***FONCTION  QLXPRI EVALUER LA PRIORITE D'UN OPERATEUR
      FUNCTION QLXPRI(OPR)
      INTEGER QLXPRI
      CHARACTER *(*) OPR
      INTEGER QLXPRIL
      PARAMETER (MAXOPER=23)
      INTEGER PRI(MAXOPER)
      CHARACTER *4 LISTE(MAXOPER), OPRTR
      LOGICAL LEFTPRI
      SAVE LISTE, PRI
      DATA LISTE/        ')' ,       ']' ,       'U+' ,      'U-' ,
                        '**' ,       '*' ,        '/' ,       '+' ,
                         '-' ,       '<' ,        '>' ,      '==' ,
                        '<=' ,      '>=' ,       '<>' ,      '><' ,
                        'NOT',      'AND',       'OR' ,      'XOR',
                         ':=' ,      '(' ,        '[' /
      DATA PRI  /  150 ,       150 ,       101  ,       101 ,
                    91 ,        81 ,        81  ,        71 ,
                    71 ,        61 ,        61  ,        61 ,
                    61 ,        61 ,        61  ,        61 ,
                    51 ,        41 ,        41  ,        41 ,
                    10 ,         1 ,         1        /
      OPRTR = OPR
      LEFTPRI = .FALSE.
1     DO I = 1,MAXOPER
         IF(OPRTR.EQ.LISTE(I)) $(
            IF(LEFTPRI)
              QLXPRI = I + PRI(I)*100
            ELSE
              QLXPRI = I + (PRI(I)-MOD(PRI(I),2))*100
            RETURN
            $)
      QLXPRI = 0
      RETURN
      ENTRY QLXPRIL(OPR)
      OPRTR = OPR
      LEFTPRI = .TRUE.
      GOTO 1
      END
* 
      SUBROUTINE QLXPRNT(QUOI,COMMENT)
      INTEGER QUOI(*), COMMENT(*)
      CHARACTER *120 FMT
      INTEGER ARGDIMS
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
      L1 = ARGDIMS(1)
      L2 = MIN(120/KARMOT,ARGDIMS(2))
      IF(L1.LT.1 .OR. L2.LT.1) RETURN
      WRITE(FMT,LINEFMT)(COMMENT(I),I=1,L2)
100   FORMAT(20 A CARMOT)
      WRITE(6,FMT)(QUOI(I),I=1,L1)
      RETURN
      END
* 
***S/P QLXRPN CONVERSION A NOTATION POSTFIXE
      SUBROUTINE QLXRPN(TOK,TOKENS,MAXTKNS,NTOKEN,TOKTYPE,
                        PILEOP,MAXOPS,NOPER,ERR)
      CHARACTER *(*) TOK
      INTEGER MAXTKNS,NTOKEN,MAXOPS,NOPER
      INTEGER TOKENS(MAXTKNS), TOKTYPE(MAXTKNS)
      EXTERNAL QLXPRI, QLXPRIL
      INTEGER  QLXPRI, QLXPRIL
      LOGICAL ERR
      CHARACTER *4 TOKEN
      CHARACTER *4 PILEOP(MAXOPS)
      IF(ERR)RETURN
      TOKEN = TOK
      IF(TOKEN.EQ.LPAREN .OR. TOKEN.EQ.LBRAK) $(
         NOPER = MIN(NOPER+1 , MAXOPS)
         PILEOP(NOPER) = TOKEN
         $)
      ELSE IF(TOKEN.EQ.RPAREN) $(
         WHILE(PILEOP(NOPER) .NE. LPAREN .AND. _
               PILEOP(NOPER) .NE. LBRAK  .AND. _
               PILEOP(NOPER) .NE. DOLLAR) $(
            CALL QLXOPR(TOKENS,NTOKEN,TOKTYPE,
                        MOD(QLXPRI(PILEOP(NOPER)),100),ERR)
            NOPER = NOPER - 1
            $)
         IF(PILEOP(NOPER).EQ.LPAREN)
            NOPER = NOPER-1
         ELSE
            ERR = .TRUE.
         $)
      ELSE IF(TOKEN.EQ.RBRAK) $(
         WHILE(PILEOP(NOPER) .NE. LPAREN .AND. _
               PILEOP(NOPER) .NE. LBRAK  .AND. _
               PILEOP(NOPER) .NE. DOLLAR) $(
            CALL QLXOPR(TOKENS,NTOKEN,TOKTYPE,
                        MOD(QLXPRI(PILEOP(NOPER)),100),ERR)
            NOPER = NOPER - 1
            $)
         IF(PILEOP(NOPER).EQ.LBRAK) $(
            CALL QLXOPR(TOKENS,NTOKEN,TOKTYPE,
                        MOD(QLXPRI(RBRAK),100),ERR)
            NOPER = NOPER-1
            $)
         ELSE
            ERR = .TRUE.
         $)
      ELSE IF(TOKEN.EQ.DOLLAR) $(
         WHILE(PILEOP(NOPER) .NE. LPAREN .AND. _
               PILEOP(NOPER) .NE. LBRAK  .AND. _
               PILEOP(NOPER) .NE. DOLLAR) $(
            CALL QLXOPR(TOKENS,NTOKEN,TOKTYPE,
                        MOD(QLXPRI(PILEOP(NOPER)),100),ERR)
            NOPER = NOPER - 1
            $)
         IF(PILEOP(NOPER).EQ.DOLLAR) $(
            NOPER = NOPER-1
            $)
         ELSE
            ERR = .TRUE.
         $)
      ELSE $(
         WHILE(QLXPRIL(PILEOP(NOPER)).GT.QLXPRI(TOKEN))$(
            CALL QLXOPR(TOKENS,NTOKEN,TOKTYPE,
                        MOD(QLXPRI(PILEOP(NOPER)),100),ERR)
            NOPER = NOPER -1
            $)
         NOPER = MIN(NOPER+1 , MAXOPS)
         PILEOP(NOPER) = TOKEN
         $)
      RETURN
      END
* 
***FONCTION QLXSKP     RETOURNE UN CARACTERE AUTRE QUE ICAR
      FUNCTION QLXSKP(ICAR)
      CHARACTER * 1 QLXSKP
      CHARACTER *1 ICAR
*
*
*AUTEUR M.VALIN  RPN  JUIN 1983
*
*OBJET
*        RETOURNE LE PREMIER CARACTERE D'UNE LIGNE DE TEXTE,
*        QUI NE SOIT PAS EGAL A L'ARGUMENT.
*ARGUMENT
*        ICAR      ENTIER SERVANT D'ARGUMENT D'ENTREE.IL DESIGNE
*                  LE CARACTERE A ETRE IGNORE DANS LA LIGNE DE TEXTE.
**
      EXTERNAL QLXCHR
      CHARACTER *1 CTMP, QLXCHR
*
      REPEAT $(
         CTMP = QLXCHR()
         $)
      UNTIL(CTMP <> ICAR)
      QLXSKP = CTMP
*
      RETURN
      END
* 
***S/P QLXTOK
      SUBROUTINE QLXTOK
*
*
*AUTEUR   M.VALIN   RPN   JUIN 1983
*
*OBJET(QLXTOK)
*        DECOMPOSE UNE LIGNE DE TEXTE EN TOKENS DE DIFFERENTS
*        TYPES,IDENTIFIE LA LONGUEUR DU TOKEN ET SON TYPE.
*ARGUMENTS
*        TOKEN
*        (S)
*
*        LEN       NOMBRE DE CARACTERE DANS UN TOKEN
*        (S)
*
*        TYPE      TYPE DU TOKEN(CLE ALPHANUMERIQUE,NOMBRE
*        (S)       ENTIER OU REEL,CHAINE DE CARACTERE OU SYMBOLE).
*
*        JVAL,ZVAL LES VALEURS D'UN NOMBRE ENTIER OU REEL,
*        (S)       CONTENU DANS UN TOKEN.
*
      INTEGER DELIM,ISIGN,ITYP
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
**
      INTPOINT LOCVAR,LOCCNT
      EXTERNAL QLXCHR, QLXNUM
      CHARACTER *1 IC, QLXCHR
      INTEGER  QLXNUM
      IVAL=-1
      TOKEN = ' '
*
      REPEAT $(
         IC = QLXCHR()
         $)
      UNTIL(IC<>BLANK)  # CHERCHE UN CARACTERE AUTRE QU'UN BLANC
      LENG=1
      TOKEN(1:1)=IC
      IF((IC.GE.LETA.AND.IC.LE.LETZ).OR.IC.EQ.ATSIGN.OR.IC.EQ.UNDER
          .OR. (IC >= 'a' .AND. IC <= 'z'))$(
         IC=QLXCHR()
         WHILE((IC.GE.LETA .AND.IC .LE. LETZ).OR. _
            (IC.GE.DIG0 .AND. IC.LE.DIG9) _
            .OR. (IC >= 'a' .AND. IC <= 'z'))  $(
            LENG=MIN(81,LENG+1)
            TOKEN(LENG:LENG)=IC
            IC=QLXCHR()
            $)
         IF(LENG.GT.8)  $(
            TYPE=STRING
            $)
         ELSE $(
            TYPE=CLE
            $)
         CALL QLXBAK(IC)
         $)
*
      ELSE IF(IC.EQ.SQUOTE .OR. IC.EQ.DQUOTE)  $(
         LENG=0
         REPEAT $(
            LENG=MIN(80,LENG+1)
            TOKEN(LENG:LENG)=QLXCHR()
            $)
         UNTIL(TOKEN(LENG:LENG) == IC)    # LOOP UNTIL DELIMITER
         TOKEN(LENG:LENG) = ' '
         LENG = LENG -1
         IF (IC .EQ. DQUOTE) LENG = MIN(LENG,KARMOT)
         TYPE=STRING
         $)
*
      ELSE IF((IC.GE.DIG0 .AND. IC.LE.DIG9) _
             .OR.(IC.EQ.PERIOD)) $(
         TYPE=QLXNUM(TOKEN,LENG)
         ISIGN=1
         $)
*
      ELSE IF((IC.EQ.PLUS .OR. IC.EQ.MINUS).AND.(.NOT.INEXPR) ) $(
         IF(IC.EQ.PLUS)  $(
            ISIGN=1
            $)
         ELSE  $(
            ISIGN=-1
            $)
         IC=QLXCHR()
         IF((IC.GE.DIG0 .AND. IC.LE.DIG9).OR. IC.EQ. PERIOD)  $(
            TOKEN(1:1)=IC
            TYPE=QLXNUM(TOKEN,LENG)
            $)
         ELSE  $(
            CALL QLXBAK(IC)
            TYPE=OPER
            $)
         $)
      ELSE IF(IC.EQ.STAR) $(
         TYPE = OPER
         IC=QLXCHR()
         IF(IC.EQ.STAR) $(
            LENG = 2
            TOKEN = '**'
            $)
         ELSE
            CALL QLXBAK(IC)
         $)
      ELSE IF(IC.EQ.'<' .OR. IC.EQ.'>' .OR. IC.EQ.'=' .OR. IC.EQ.':') $(
         TYPE = OPER
         IC=QLXCHR()
         IF(IC.EQ.'<' .OR. IC.EQ.'>' .OR. IC.EQ.'=') $(
            LENG = 2
            TOKEN(2:2) = IC
            $)
         ELSE
            CALL QLXBAK(IC)
         $)
      ELSE  $(
         TYPE=OPER
         $)
*
      IF((LENG.GT.80) .OR. (TYPE.EQ.PASBON)) $(
         TOKEN = 'SCRAP'
         TYPE=PASBON
         CALL QLXERR(21014,'QLXTOK')
         $)
      IF(TYPE.EQ.ENTIER)  $(
         READ(TOKEN,'(I20)')JVAL
         JVAL=SIGN(JVAL,ISIGN)
         $)
      ELSE IF(TYPE.EQ.REEL) $(
         READ(TOKEN,'(G20.3)')ZVAL
         ZVAL=SIGN(ZVAL,FLOAT(ISIGN))
         $)
      ELSE IF(TYPE.EQ.OCTAL) $(
         READ(TOKEN,'(O20)')JVAL
         TYPE=ENTIER
         JVAL=SIGN(JVAL,ISIGN)
         $)
      IF(TYPE.EQ.CLE)  $(
         CALL QLXFND(TOKEN(1:8),LOCVAR,LOCCNT,LIMITS,ITYP)
         IF (ITYP .EQ. -1)
           $(
             TYPE = STRING
             LENG = MIN(LENG,KARMOT)
           $)
         ELSE IF ((ITYP .EQ. 0) .OR. (ITYP .EQ. 1))
            PEEK(LOCVAR,1,JVAL)
         ELSE
            JVAL = -1
         $)
      LEN=LENG
*
      RETURN
      END
* 
      SUBROUTINE QLXUNDF(IKEY)
      INTEGER IKEY(*)
      CHARACTER *8 CKEY
      INTEGER ARGDIMS
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
*
*      WRITE(CKEY,LINFMT)(IKEY(I),I=1,ARGDIMS(1))
      WRITE(CKEY,101)(IKEY(I),I=1,ARGDIMS(1))
101   FORMAT(2 A CARMOT)
      CALL QLXUDF(SCRAP,CKEY)
      RETURN
      END
* 
      FUNCTION QLXVAL(KLE,ERR)
      INTEGER QLXVAL
*
      CHARACTER *(*) KLE
      LOGICAL ERR
      INTEGER IND,VAL,DUM
*
      CALL QLXIND(IND,ERR)
*
      VAL = 0
      IF(.NOT. ERR)  $(
         CALL QLXADI(KLE,IND,VAL,DUM,ERR)
         $)
*
      QLXVAL=VAL
*
      RETURN
      END
* 
***S/P QLXXPR TRAITER UNE EXPRESSION ARITHMETIQUE OU LOGIQUE
      SUBROUTINE QLXXPR(ERR)
      LOGICAL ERR
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
      PARAMETER (MAXTKNS=65,MAXOPS=30)
      INTEGER TOKENS(MAXTKNS), TOKTYPE(MAXTKNS), NTOKEN
      INTEGER NOPER
      CHARACTER *4 PILEOP(MAXOPS)
      LOGICAL UNARY, FINI, FIRST
      INTEGER PLEV, QLXPRI
      EXTERNAL QLXPRI
*
      INEXPR = .TRUE.
      NTOKEN = 0
      PLEV = 0
      BLEV = 0
      UNARY = .TRUE.
      ERR = .FALSE.
      FINI = .FALSE.
      FIRST = .TRUE.
      NOPER = 1
      PILEOP(1) = DOLLAR
      WHILE( .NOT.FINI .AND. NTOKEN.LT.MAXTKNS             _
             .AND. NOPER.LT.MAXOPS .AND. .NOT.ERR)$(
         IF(.NOT.FIRST) CALL QLXTOK
         FIRST = .FALSE.
         IF(TYPE.EQ.CLE)$(
            NTOKEN = NTOKEN + 1
            CALL QLXFND(TOKEN(1:8),LOCVAR,LOCCNT,LIMITES,ITYP)
            IF(ITYP.NE.0 .AND. ITYP.NE.1) ERR=.TRUE.
            TOKENS(NTOKEN) = LOCVAR
            TOKTYPE(NTOKEN) = LIMITES + 1
            IF(.NOT. UNARY) ERR=.TRUE.
            UNARY = .FALSE.
            $)
         ELSE IF(TYPE.EQ.ENTIER .OR. TYPE.EQ.REEL)$(
            NTOKEN = NTOKEN + 1
            TOKENS(NTOKEN) = JVAL
            TOKTYPE(NTOKEN) = 0
            IF(.NOT. UNARY) ERR=.TRUE.
            UNARY = .FALSE.
            $)
         ELSE IF(QLXPRI(TOKEN(1:4)).GT.0) $(     # OPERATEUR RECONNU
            IF(TOKEN(1:2).EQ.'( ')
               PLEV = PLEV + 1
            ELSE IF(TOKEN(1:2).EQ.') ')
               PLEV = PLEV - 1
            ELSE IF(TOKEN(1:2).EQ.'[ ')
               BLEV = BLEV + 1
            ELSE IF(TOKEN(1:2).EQ.'] ')
               BLEV = BLEV - 1
            IF(PLEV.LT.0 .OR. BLEV.LT.0) $(
               FINI = .TRUE.
               CALL QLXBAK(TOKEN(1:1))
               BREAK
               $)
            IF(UNARY) $(
               IF(TOKEN(1:2).EQ.'+ ')       TOKEN(1:2) = 'U+'
               ELSE IF(TOKEN(1:2).EQ.'- ') TOKEN(1:2) = 'U-'
               ELSE IF(TOKEN(1:2).NE.'( ' .AND. TOKEN(1:2).NE.'[ ') ERR=.TRUE.
               $)
            UNARY = TOKEN(1:1).NE.')' .AND. TOKEN(1:1).NE.']'
            CALL QLXRPN(TOKEN,TOKENS,MAXTKNS,NTOKEN,TOKTYPE,
                        PILEOP,MAXOPS,NOPER,ERR)
            $)
         ELSE IF(TOKEN(1:1).EQ.',' .OR. TOKEN(1:1).EQ.'$'
                                 .OR. TOKEN(1:2).EQ.':=') $( # TERMINATEUR
            CALL QLXRPN(DOLLAR,TOKENS,MAXTKNS,NTOKEN,TOKTYPE,
                        PILEOP,MAXOPS,NOPER,ERR)
            FINI = .TRUE.
            CALL QLXBAK(TOKEN(1:1))
            $)
         ELSE $(
            WRITE(6,'(A8,A)')TOKEN(1:8),' IS INVALID'
            ERR = .TRUE.
            $)
         $)
      IF (PLEV.GT.0 .OR. .NOT.FINI .OR. BLEV.GT.0
          .OR. NTOKEN.NE.1 ) ERR = .TRUE.
      INEXPR = .FALSE.
      IF(.NOT.ERR) $(
         TOKEN    = ' '
         JVAL     = TOKENS(1)
         IF(TOKTYPE(1).GT.0)
            TYPE = ADRESSE
         ELSE IF(ABS(JVAL).LE.MAXINT)
            TYPE = ENTIER
         ELSE
            TYPE = REEL
         $)
      IF(ERR)
         CALL QLXERR(81005,'QLXEXPR')
      RETURN
      END
* 
      SUBROUTINE READLX(UNIT,KEND,KERR)
*
***S/R READLX - INTERPRETE DE DIRECTIVES
*
*AUTEUR   - M. VALIN
*
*LANGAGE  - RATFOR
*
*APPEL    - CALL READLX(UNIT,KEND,KERR)
*
*MODULES  - QLXFND,QLXTOK,QLXASG,QLXCALL,QLXERR,QLXFLSH
*
*ARGUMENTS
*         - UNIT - UNITE D'ENTREE
*         - KEND - 0 = TOUT EST NORMAL
*                  ?
*
*         - KERR -
*
      COMMON/QLXTOK1/LEN,TYPE,ZVAL,INEXPR
      LOGICAL INEXPR
      INTEGER LEN,TYPE,JVAL
      REAL ZVAL
      EQUIVALENCE (ZVAL,JVAL)
*
      COMMON/QLXTOK2/TOKEN
      CHARACTER *80 TOKEN
*
      COMMON /QLXBUFF/ NC,LAST,INPFILE,EOFL,NERR,SKIPFLG
      COMMON /QLXBUFF/ CURREC,READREC,TMPFILE
      INTEGER NC,LAST,INPFILE,NERR,SKIPFLG,CURREC,READREC,TMPFILE
      LOGICAL EOFL
      COMMON /QLXBUF2/ INLINE
      CHARACTER *101 INLINE
      CHARACTER * 20 LINEFMT
      INTEGER KARMOT
      COMMON /QLXFMT/ LINEFMT
      COMMON /QLXFMT2/ KARMOT
**
      EXTERNAL QLXNVAR,QLXPRNT,QLXUNDF
      INTEGER UNIT,KEND,IVAR,ICOUNT
      INTPOINT LOCCNT,LOCVAR,IICNT
      INTEGER LIMITS,ITYP
      LOGICAL FIN,ERR
      PARAMETER (MAXSTRU=20)
      INTEGER NXTELSE(0:2), NEXTIF(0:2), STYPE(MAXSTRU), SKIPF(MAXSTRU)
      INTEGER READBSE(MAXSTRU)
      INTEGER NSTRUC,ier
      character * 128 nomscra
*
      DATA NXTELSE / 1, 0, 2/
      DATA NEXTIF  / 0, 2, 2/
*
      DATA KARMOT /CARMOT/
*
      WRITE(LINEFMT,'(A,I2,A)') '(25 A',KARMOT,')'
      KERRMAX = 999999
      IF(KERR.LT.0 ) KERRMAX = MIN(ABS(KERR),KERRMAX)
      NC=1
      LAST=0
      INPFILE=UNIT
      EOFL=.FALSE.
      NERR=0
      FIN=.FALSE.
      INEXPR=.FALSE.
      STYPE(1) = 0
      SKIPF(1) = 0
      NSTRUC = 1
      CURREC=0
      READREC=0
      READBSE(1)=0
      nomscra='XXXXQLX'
      tmpfile = 0
      ier = fnom(tmpfile,nomscra,'D77+SCRATCH+FMT',20)
      CALL QLXINX(QLXPRNT,'PRINT',IDUM,0202,2)
      CALL QLXINX(QLXNVAR,'DEFINE',IDUM,0202,2)
      CALL QLXINX(QLXUNDF,'UNDEF',IDUM,0101,2)
      WHILE(.NOT.FIN .AND. NERR.LT.KERRMAX .AND. NSTRUC.LT.MAXSTRU) $(
         SKIPFLG = SKIPF(NSTRUC)
         ERR=.FALSE.
         CALL QLXTOK
         IF(TYPE.EQ.CLE)  $(
            CALL QLXFND(TOKEN,LOCVAR,LOCCNT,LIMITS,ITYP)
            IF(ITYP.EQ.1 .AND. SKIPF(NSTRUC).EQ.0)  $(  # ASSIGNATION
               PEEK(LOCCNT,1,IICNT)
               CALL QLXASG(LOCVAR,IICNT,LIMITS,ERR)
               POKE(LOCCNT,1,IICNT)
               $)
            ELSE IF(ITYP.EQ.2 .AND. SKIPF(NSTRUC).EQ.0)  $(  # APPEL
               CALL QLXCALL(LOCVAR,LOCCNT,LIMITS,ERR)
               $)
            ELSE IF(ITYP.EQ.3)  $(                  # IF CONDITION
               NSTRUC = NSTRUC + 1
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NEXTIF(SKIPF(NSTRUC-1))
               IF(SKIPF(NSTRUC).EQ.0) $(            # NOT ALREADY SKIPPING
                  CALL QLXTOK
                  IF(TOKEN(1:1).NE.DOLLAR) $(
                     CALL QLXXPR(ERR)
                     IF(ERR) BREAK
                     IF(TYPE.EQ.ADRESSE)
                        PEEK(JVAL,1,JVAL)
                     IF(IAND(JVAL,MASK(16)).EQ.0)
                        SKIPF(NSTRUC) = 1
                     $)
                  ELSE
                     CALL QLXBAK(DOLLAR)
                  $)
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.4) $(                # ELSE
               IF(STYPE(NSTRUC).NE.3) BREAK
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NXTELSE(SKIPF(NSTRUC))
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.5) $(                # ENDIF
               IF(STYPE(NSTRUC).NE.3 .AND. STYPE(NSTRUC).NE.4) BREAK
               SKIPF(NSTRUC) = 0
               NSTRUC = NSTRUC - 1
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.6)  $(                  # WHILE STATEMENT
               NSTRUC = NSTRUC + 1
               STYPE(NSTRUC) = ITYP
               SKIPF(NSTRUC) = NEXTIF(SKIPF(NSTRUC-1))
               IF (READREC <> 0)
                 READBSE(NSTRUC) = READREC -1
               ELSE
                 READBSE(NSTRUC) = CURREC
               IF(SKIPF(NSTRUC).EQ.0) $(            # NOT ALREADY SKIPPING
                  CALL QLXTOK
                  IF(TOKEN(1:1).NE.DOLLAR) $(
                     CALL QLXXPR(ERR)
                     IF(ERR) BREAK
                     IF(TYPE.EQ.ADRESSE)
                        PEEK(JVAL,1,JVAL)
                     IF(IAND(JVAL,MASK(16)).EQ.0)
                        SKIPF(NSTRUC) = 1
                     $)
                  ELSE
                     CALL QLXBAK(DOLLAR)
                  $)
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.EQ.7) $(                # ENDWHILE
               IF(STYPE(NSTRUC).NE.6) BREAK
               IF (SKIPF(NSTRUC) .EQ. 0)
                 READREC = READBSE(NSTRUC)
               SKIPF(NSTRUC) = 0
               NSTRUC = NSTRUC - 1
               CALL QLXFLSH(DOLLAR)
               $)
            ELSE IF(ITYP.GE.10 .AND. ITYP.LE.13 .AND. SKIPF(NSTRUC).EQ.0)  $(
               KERR=NERR
               KEND=ITYP-10
               FIN=.TRUE.
               $)
            ELSE IF(SKIPF(NSTRUC).NE.0) $(
               CALL QLXFLSH(DOLLAR)       # SKIPPING... DO NOT EXECUTE
               $)
            ELSE  $(
               CALL QLXERR(21015,'READLX')
               ERR=.TRUE.
               $)
            $)
         ELSE  $(
            CALL QLXERR(21016,'READLX')
            ERR=.TRUE.
            $)
         IF(ERR.AND.(TOKEN(1:1).NE.DOLLAR.OR. TYPE.NE.OPER))  $(
            CALL QLXFLSH(DOLLAR)
            $)
         $)
      IF(NSTRUC.GT.1) $(
         WRITE(6,*)' ERREUR DANS LA STRUCTURE DES BLOCS IF THEN ELSE'
         KERR = NERR + 1
         KEND = -1
         $)
*
      CLOSE(TMPFILE,STATUS='DELETE')
      RETURN
      END
