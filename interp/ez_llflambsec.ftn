*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
      subroutine ez_llflambsec(alat,elon,xi,xj,alat1,elon1,dx,elonv,alatan,
     $     ierr)
c$$$  subprogram  documentation  block
c
c subprogram:  llflamb        lambert(i,j) to lat/lon for grib
c   prgmmr: stackpole        org: nmc42       date:88-11-28
c
c abstract: converts the coordinates of a location on earth given in a
c   grid coordinate system overlaid on a lambert conformal tangent
c   cone projection true at a given n or s latitude to the
c   natural coordinate system of latitude/longitude
c   llflamb is the reverse of w3fb11.
c   uses grib specification of the location of the grid
c
c program history log:
c   88-11-25  original author:  stackpole, w/nmc42
c
c usage:  call llflamb(alat,elon,xi,xj,alat1,elon1,dx,elonv,alatan,ierr,
c                                   ierr)
c   input argument list:
c     xi       - i coordinate of the point  real*4
c     xj       - j coordinate of the point  real*4
c     alat1    - latitude  of lower left point of grid (point 1,1)
c                latitude <0 for southern hemisphere; real*4
c     elon1    - longitude of lower left point of grid (point 1,1)
c                  east longitude used throughout; real*4
c     dx       - mesh length of grid in meters at tangent latitude
c     elonv    - the orientation of the grid.  i.e.,
c                the east longitude value of the vertical meridian
c                which is parallel to the y-axis (or columns of
c                the grid) along which latitude increases as
c                the y-coordinate increases.  real*4
c                this is also the meridian (on the other side of the
c                tangent cone) along which the cut is made to lay
c                the cone flat.
c     alatan   - the latitude at which the lambert cone is tangent to
c                (touches or osculates) the spherical earth.
c                 set negative to indicate a
c                 southern hemisphere projection; real*4
c
c   output argument list:
c     alat     - latitude in degrees (negative in southern hemi.)
c     elon     - east longitude in degrees, real*4
c     ierr     - .eq. 0   if no problem
c                .ge. 1   if the requested xi,xj point is in the
c                         forbidden zone, i.e. off the lambert map
c                         in the open space where the cone is cut.
c                  if ierr.ge.1 then alat=999. and elon=999.
c
c   remarks: formulae and notation loosely based on hoke, hayes,
c     and renninger's "map projections and grid systems...", march 1981
c     afgwc/tn-79/003
c
c attributes:
c   language: ibm vs fortran
c   machine:  nas
c
c$$$
c
         logical newmap
         data  rerth /6.3712e+6/, pi/3.14159/, oldrml/99999./
c
c        preliminary variables and redifinitions
c
c        h = 1 for northern hemisphere; = -1 for southern
c
         if(alatan.gt.0) then
           h = 1.
         else
           h = -1.
         endif
c
         piby2 = pi/2.
         radpd = pi/180.0
         degprd = 1./radpd
         rebydx = rerth/dx
         alatn1 = alatan * radpd
         an = h * sin(alatn1)
         cosltn = cos(alatn1)
c
c        make sure that input longitude does not pass through
c        the cut zone (forbidden territory) of the flat map
c        as measured from the vertical (reference) longitude
c
         elon1l = elon1
         if((elon1-elonv).gt.180.)
     &     elon1l = elon1 - 360.
         if((elon1-elonv).lt.(-180.))
     &     elon1l = elon1 + 360.
c
         elonvr = elonv * radpd
c
c        radius to lower left hand (ll) corner
c
         ala1 =  alat1 * radpd
         rmll = rebydx * ((cosltn**(1.-an))*(1.+an)**an) *
     &           (((cos(ala1))/(1.+h*sin(ala1)))**an)/an
c
c        use rmll to test if map and grid unchanged from previous
c        call to this code.  thus avoid unneeded recomputations.
c
         if(rmll.eq.oldrml) then
           newmap = .false.
         else
           newmap = .true.
           oldrml = rmll
c
c          use ll point info to locate pole point
c
           elo1 = elon1l * radpd
           arg = an * (elo1-elonvr)
           polei = 1. - h * rmll * sin(arg)
           polej = 1. + rmll * cos(arg)
         endif
c
c        radius to the i,j point (in grid units)
c              yy reversed so positive is down
c
         xx = xi - polei
         yy = polej - xj
         r2 = xx**2 + yy**2
c
c        check that the requested i,j is not in the forbidden zone
c           yy must be positive up for this test
c
         theta = pi*(1.-an)
         beta = abs(atan2(xx,-yy))
         ierr = 0
         if(beta.le.theta) then
           ierr = 1
           alat = 999.
           elon = 999.
           if(.not.newmap)  return
         endif
c
c        now the magic formulae
c
         if(r2.eq.0) then
           alat = h * 90.
           elon = elonv
         else
c
c          first the longitude
c
           elon = elonv + degprd * atan2(h*xx,yy)/an
           elon = amod(elon+360., 360.)
c
c          now the latitude
c          recalculate the thing only if map is new since last time
c
           if(newmap) then
             aninv = 1./an
             aninv2 = aninv/2.
             thing = ((an/rebydx) ** aninv)/
     &         ((cosltn**((1.-an)*aninv))*(1.+ an))
           endif
           alat = h*(piby2 - 2.*atan(thing*(r2**aninv2)))*degprd
         endif
c
c        following to assure error values if first time thru
c         is off the map
c
         if(ierr.ne.0) then
           alat = 999.
           elon = 999.
           ierr = 2
         endif
         return
         end
