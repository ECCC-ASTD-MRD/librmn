*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
       subroutine ez_lambsecfll(xi,xj,alat,elon,alat1,elon1,dx,elonv,alatan)
c$$$   subprogram  documentation  block
c
c subprogram:  w3fb11        lat/lon to lambert(i,j) for grib
c   prgmmr: stackpole        org: nmc42       date:88-11-28
c
c abstract: converts the coordinates of a location on earth given in
c   the natural coordinate system of latitude/longitude to a grid
c   coordinate system overlaid on a lambert conformal tangent cone
c   projection true at a given n or s latitude. w3fb11 is the reverse
c   of w3fb12. uses grib specification of the location of the grid
c
c program history log:
c   88-11-25  original author:  stackpole, w/nmc42
c
c usage:  call lambfll (xi,xj,alat,elon,alat1,elon1,dx,elonv,alatan)
c   input argument list:
c     alat     - latitude in degrees (negative in southern hemis)
c     elon     - east longitude in degrees, real*4
c     alat1    - latitude  of lower left point of grid (point (1,1))
c     elon1    - longitude of lower left point of grid (point (1,1))
c                all real*4
c     dx       - mesh length of grid in meters at tangent latitude
c     elonv    - the orientation of the grid.  i.e.,
c                the east longitude value of the vertical meridian
c                which is parallel to the y-axis (or columns of
c                of the grid) along which latitude increases as
c                the y-coordinate increases.  real*4
c                this is also the meridian (on the back side of the
c                tangent cone) along which the cut is made to lay
c                the cone flat.
c     alatan   - the latitude at which the lambert cone is tangent to
c                (touching) the spherical earth.
c                 set negative to indicate a
c                 southern hemisphere projection.
c
c   output argument list:
c     xi       - i coordinate of the point specified by alat, elon
c     xj       - j coordinate of the point; both real*4
c
c   remarks: formulae and notation loosely based on hoke, hayes,
c     and renninger's "map projections and grid systems...", march 1981
c     afgwc/tn-79/003
c
c attributes:
c   language: ibm vs fortran
c   machine:  nas
c
c$$$
c
         data  rerth /6.3712e+6/, pi/3.14159/
c
c        preliminary variables and redifinitions
c
c        h = 1 for northern hemisphere; = -1 for southern
c
         if(alatan.gt.0) then
           h = 1.
         else
           h = -1.
         endif
c
         radpd = pi/180.0
         rebydx = rerth/dx
         alatn1 = alatan * radpd
         an = h * sin(alatn1)
         cosltn = cos(alatn1)
c
c        make sure that input longitudes do not pass through
c        the cut zone (forbidden territory) of the flat map
c        as measured from the vertical (reference) longitude.
c
         elon1l = elon1
         if((elon1 - elonv).gt.180.)
     &     elon1l = elon1 - 360.
         if((elon1 - elonv).lt.(-180.))
     &     elon1l = elon1 + 360.
c
         elonl = elon
         if((elon  - elonv).gt.180.)
     &     elonl  = elon  - 360.
         if((elon - elonv).lt.(-180.))
     &     elonl = elon + 360.
c
         elonvr = elonv *radpd
c
c        radius to lower left hand (ll) corner
c
         ala1 =  alat1 * radpd
         rmll = rebydx * (((cosltn)**(1.-an))*(1.+an)**an) *
     &           (((cos(ala1))/(1.+h*sin(ala1)))**an)/an
c
c        use ll point info to locate pole point
c
         elo1 = elon1l * radpd
         arg = an * (elo1-elonvr)
         polei = 1. - h * rmll * sin(arg)
         polej = 1. + rmll * cos(arg)
c
c        radius to desired point and the i j too
c
         ala =  alat * radpd
         rm = rebydx * ((cosltn**(1.-an))*(1.+an)**an) *
     &           (((cos(ala))/(1.+h*sin(ala)))**an)/an
c
         elo = elonl * radpd
         arg = an*(elo-elonvr)
         xi = polei + h * rm * sin(arg)
         xj = polej - rm * cos(arg)
c
c        if coordinate less than 1
c        compensate for origin at (1,1)
c
         if(xi.lt.1.)  xi = xi - 1.
         if(xj.lt.1.)  xj = xj - 1.
c
      return
      end
