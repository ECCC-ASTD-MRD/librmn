/* RMNLIB - Library of useful routines for C and FORTRAN programming
 * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
 *                          Environnement Canada
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation,
 * version 2.1 of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/types.h>
#include <math.h>

#include <App.h>
#include <rmn/rpnmacros.h>
#include <bitPacking.h>

extern double f77name(f_pow)(double *base, int32_t *i);

#define PASTE(a,b) a##b
#define CAT(a,b) PASTE(a,b)

//! Pack float to integers
void * CAT(compact_p_,FLOAT_TYPE)(
    //! [in] Array of floating point numbers
    const void * const unpackedArrayOfFloat,
    //! [in,out] Format information of packed integer numbers
    void * const packedHeader,
    //! [out] Array of integers
    void * const packedArrayOfInt,
    //! [in] Number of elements in the floating point array
    const int elementCount,
    //! [in] Integer size in bit
    const int packedTokenBitSize,
    //! [in] Pack the last bit of integer inside array
    const int offset,
    //! [in] Floating point number spacing indicator
    const int stride,
    //! [in] Set to 1 when there are missing values, 0 otherwise
    const int hasMissing,
    //! [in] Missing value identifier
    const void * const missingTag,
    //! [out] Minimun value in array
    double * const min,
    //! [out] Maximum value in array
    double * const max
) {
#include "compact_common.h"

    // Compact a floating point array into an integer array
    FLOAT_TYPE * const arrayOfFloat = (FLOAT_TYPE *)unpackedArrayOfFloat;
    uint32_t * const packHeader = (uint32_t *)packedHeader;
    uint32_t * arrayOfInt = (uint32_t *)packedArrayOfInt;

    // Determine the missing token and header style
    uint32_t missingToken = packedTokenBS != wordSize ? ~(-1 << packedTokenBS) : ~0;

    int headerStyle;
    if ((( &packHeader[3] == arrayOfInt ) && ( offset == 24 )) ||
        (( &packHeader[0] == arrayOfInt ) && ( offset == 120 )) ) {
        headerStyle = 1;
    } else {
        headerStyle = 2;
        if ( elementCount > (powerOf2s[28] - 1) ) {
            Lib_Log(APP_LIBRMN, APP_ERROR, "%s: element count overflow in xxpack header\n", __func__);
            return NULL;
        }
    }
    const uint32_t countLower20 = (elementCount << 12 ) >> 12;
    const uint32_t countUpper8  = (elementCount << 4 ) >> 24;

    const float missingValueTag = *((FLOAT_TYPE *)missingTag);

    // Obtain the minimum and maximun
    double maxFloat, minFloat;
    if ( hasMissing == 0 ) {
        // No missing value indicated
        maxFloat = arrayOfFloat[0];
        minFloat = arrayOfFloat[0];

        for (int i = stride; i < elementCount * stride; i += stride) {
            if ( arrayOfFloat[i] < minFloat ) {
                minFloat = arrayOfFloat[i];
            } else if ( arrayOfFloat[i] > maxFloat ) {
                maxFloat = arrayOfFloat[i];
            }
        }
    } else {
        // Existence of missing value indicated
        // initialize min and max
        int i = 0 ;
        while ( arrayOfFloat[i] == missingValueTag ) {
            i += stride;
        }
        maxFloat = arrayOfFloat[i];
        minFloat = arrayOfFloat[i];
        // traverse the array to search the actual min and max
        for (int i = stride; i < elementCount * stride; i += stride) {
            if ( arrayOfFloat[i] == missingValueTag ) {
                // ignore the missing value
            } else if ( arrayOfFloat[i] < minFloat ) {
                minFloat = arrayOfFloat[i];
            } else if ( arrayOfFloat[i] > maxFloat ) {
                maxFloat = arrayOfFloat[i];
            }
        }
    }

    if ((maxFloat > MAX_RANGE) || (minFloat < -MAX_RANGE)) {
        Lib_Log(APP_LIBRMN,APP_ERROR,"%s: floating point packer, number too large minFloat=%E maxFloat=%E\n",__func__,minFloat,maxFloat);
        exit(33);
    }
    *min = minFloat;
    *max = maxFloat;

    ALL_FLOAT rangeTemplate;
    rangeTemplate.XD = (maxFloat - minFloat)*2;
    ALL_FLOAT minFloatTemplate;
    minFloatTemplate.XD = minFloat;

    // Obtain range & minimum
    rangeTemplate.MD.mantis1 = 0;
    rangeTemplate.MD.mantis2 = 0;
    rangeTemplate.MD.mantis3 = 0;
    unsigned int tempInt = rangeTemplate.XD == 0 ? 0 : (int64_t) (( maxFloat - minFloat ) * powerOf2s[packedTokenBS] / rangeTemplate.XD);

    if ( ( tempInt == missingToken )  && ( hasMissing ) ) {
        rangeTemplate.MD.expo++;
    }

    // Obtain the scaled exponent of range and minumum float
    /* 1024 -1 = 1023 adjusted bias to account for the hidden leading mantisa bit */
    int tempExpo = (rangeTemplate.XD == 0) ? 0 : (rangeTemplate.MD.expo - 1023);

    uint32_t scaledExpOfMinFloat = minFloatTemplate.MD.expo - 1023 + 1024 - 48;

    const uint32_t scaledExpOfRange = tempExpo - packedTokenBS;

    // Obtain desired range and sign of minimum floating point number
    const uint32_t signOfMinFloat = minFloat < 0 ? 1 : 0;
    if ( minFloat == 0.0 ) {
        scaledExpOfMinFloat = scaledExpOfMinFloat & 0x00000111;
    }

    /*************************************************************************
    *                                                                       *
    *              initialize the header of the integer  array              *
    *              ===========================================              *
    *                                                                       *
    * position 0: the total number of floating point number being packed    *
    * position 1: range's exponent scaled, minimum float's exponent scaled  *
    *             down by 48 and its sign                                   *
    * position 2: mantisa of minimun float with the hidden leading bit and  *
    *             scaled 48 bit to right                                    *
    * position 3: bit size of each packed integer                           *
    *                                                                       *
    ************************************************************************/
    uint32_t headerType;
    if ( headerStyle == 1 ) {
        if (hasMissing == 1) {
            headerType = 0x7ef;
        } else {
            headerType = 0x7ff;
        }
    } else {
        if (hasMissing == 1 ) {
            headerType = 0xfef;
        } else {
            headerType = 0xfff;
        }
    }

    packHeader[0] = headerType << 20 | countLower20;
    packHeader[1] = ((scaledExpOfRange + 4096) << 16) | ((scaledExpOfMinFloat << 4) | signOfMinFloat);

    if ( minFloat == 0.0 ) {
        packHeader[2] = 0;
    } else {
        const uint32_t tempMantisa1 = minFloatTemplate.MD.mantis1;
        const uint32_t tempMantisa2 = minFloatTemplate.MD.mantis2;
        packHeader[2] = ( -1 << (wordSize - 1) ) | (tempMantisa1 << 11) | (tempMantisa2 << 8);
    }

    packHeader[3] = packedTokenBS << 8 | countUpper8;

    double mulFactor;
    {
        // Obtain multiplication factor
        double two = 2.0;
        int32_t expos_ftn;
        expos_ftn = tempExpo;
        mulFactor = powerOf2s[packedTokenBS] / f77name(f_pow)(&two, &expos_ftn);
    }

    const int lastPackBit = offset;
    int spaceInLastWord =  wordSize - ( lastPackBit % wordSize );
    const int lastSlot = ( lastPackBit / wordSize );

    uint32_t lastWordShifted = spaceInLastWord == wordSize ? 0 : arrayOfInt[lastSlot] >> spaceInLastWord;

    uint32_t * arrayPtr = &arrayOfInt[lastSlot];
    if (( spaceInLastWord == wordSize ) && ( packedTokenBS == wordSize )) {
        // direct copy

        for (int i = 0; i < elementCount * stride; i+= stride) {
            if ( ( hasMissing == 1 ) && ( arrayOfFloat[i] == missingValueTag ) ) {
                tempInt = missingToken;
            } else {
                tempInt = ( arrayOfFloat[i] - minFloat ) * mulFactor ;
            }
            *arrayPtr = tempInt;
            arrayPtr++;
        }
    } else {
        // bit by bit shuffle
        for (int i = 0; i < elementCount * stride; i += stride) {
            if ( ( hasMissing == 1 ) && ( arrayOfFloat[i] == missingValueTag ) ) {
                tempInt = missingToken;
            } else {
                tempInt = (int64_t) (( arrayOfFloat[i] - minFloat ) * mulFactor) ;
            }

            stuff(tempInt, arrayPtr, wordSize, EffectivePackedTokenSize, lastWordShifted, spaceInLastWord);
        }
    }

    // Squeezes hole left in the integer array
    if ( spaceInLastWord < wordSize ) {
        *arrayPtr = ( lastWordShifted << spaceInLastWord) |
                    ( *arrayPtr & ~(-1 << spaceInLastWord));
    }

    return (uint32_t *)arrayOfInt;
}


//! Unpack float from integers
void * CAT(compact_u_,FLOAT_TYPE)(
    //! [out] Array of floating point numbers
    void * const unpackedArrayOfFloat,
    //! [in,out] Format information of packed integer numbers
    const void * const packedHeader,
    //! [in] Array of integers
    const void * const packedArrayOfInt,
    //! [in] Number of elements in the floating point array
    const int elementCount,
    //! [in] Integer size in bit
    const int packedTokenBitSize,
    //! [in] in packing   : the last bit of integer packed inside array
    //! in unpacking : the first bit of integer packed into array
    const int offset,
    //! [in] Floating point number spacing indicator
    const int stride,
    //! [in] Operator(FLOAT_PACK, FLOAT_UNPACK)
    const int opCode,
    //! [in] Set to 1 when there are missing values, 0 otherwise
    const int hasMissing,
    //! [in] Missing value identifier
    const void * const missingTag,
    //! [out] Minimun value in array
    double * const min,
    //! [out] Maximum value in array
    double * const max
) {
#include "compact_common.h"

    uint32_t currentWord;
    uint32_t intCount;

    uint32_t rangeExponent;
    int firstPackBit;
    uint32_t bitPackInFirstWord;
    int currentSlot;
    uint32_t packInt;
    int significantBit, inSignificantBit;
    float missingValueTag = *((FLOAT_TYPE *)missingTag);
    uint32_t missingToken;
    int tokenSize;

    FLOAT_TYPE * const arrayOfFloat = (FLOAT_TYPE *)unpackedArrayOfFloat;

    // Extra space neccessary since this array is delcared as a three dimension array
    // [ stride, 2, elementCount/(stride*2)+1 ] in fotran routine aazz1
    const xxpack_struct_data * const theHeader = (xxpack_struct_data *)packedHeader;
    uint32_t * const arrayOfInt = (uint32_t *)packedArrayOfInt;
    if (( theHeader->marker == 0x7ff ) || ( theHeader->marker == 0x7ef )) {
        if ( theHeader->counter != elementCount ) {
            // legacy data with more than 2POW(20) elements but only 120-bit header and 20-bit ninj
            intCount = elementCount;
            if ((intCount & 0x3777777) != (elementCount & 0x3777777)) {
                Lib_Log(APP_LIBRMN,APP_WARNING,"%s: ninj from argument: %d different from ninj from header: %d. Argument ninj is used \n\n",__func__,elementCount, theHeader->counter);
            }
        } else {
            intCount = theHeader->counter;
        }
    } else {
        intCount = (theHeader->emptySpace)<<20 | theHeader->counter;
    }

    tokenSize = theHeader->bitSize;
    EffectivePackedTokenSize = tokenSize;
    if ( tokenSize != wordSize ) {
        missingToken = ~(-1 << tokenSize);
    } else {
        missingToken = ~0;
    }

    rangeExponent = theHeader->rangeExpo - 4096 + 127 + tokenSize;

    double mulFactor;
    {
        double two = 2.0;
        int expos_i;
        expos_i = (rangeExponent - 127 - tokenSize);
        mulFactor = f77name(f_pow)(&two, &expos_i);
    }

    double minFloat;
    if ( ( theHeader->minMantisa32 == 0 ) || ( theHeader->minExpo < 849 ) ) {
        minFloat = 0;
    } else {
        ALL_FLOAT minFloatTemplate;
        minFloatTemplate.M.sign = theHeader->minSign;
        minFloatTemplate.M.expo = theHeader->minExpo + 127 - 1024 + 48;
        minFloatTemplate.M.mantis = (theHeader->minMantisa32 >> 8 ) & 0x7fffff;
        minFloat = minFloatTemplate.X;
        /*
        Lib_Log(APP_LIBRMN, APP_DEBUG, "%s: sign=%d minExpo= %d expo=%d mantis=%x minFloat=%f mulFactor=%f \n", __func__,
            minFloatTemplate.M.sign, theHeader->minExpo, minFloatTemplate.M.expo, minFloatTemplate.M.mantis, minFloat, mulFactor);
        */
    }

    firstPackBit = offset;
    bitPackInFirstWord =  wordSize - ( firstPackBit % wordSize );
    currentSlot = ( firstPackBit / wordSize );
    currentWord = arrayOfInt[currentSlot] << ( wordSize - bitPackInFirstWord );
    /*
    Lib_Log(APP_LIBRMN,APP_DEBUG,"%s: firstPackBit=%d bitPackInFirstWord=%d currentSlot=%d currentWord=%d\n",__func__,
            firstPackBit, bitPackInFirstWord, currentSlot, currentWord);
    */
    if ( tokenSize > wordSize ) {
        significantBit = wordSize;
        inSignificantBit = tokenSize - wordSize;
    } else {
        significantBit = EffectivePackedTokenSize;
        inSignificantBit = 0;
    }

    // Unpack floating point numbers from its integer representation
    uint32_t * arrayPtr = &arrayOfInt[currentSlot];
    for (int i = 0; i < intCount * stride; i += stride) {
        extract(packInt, arrayPtr, wordSize, significantBit, currentWord, bitPackInFirstWord);
        /*Lib_Log(APP_LIBRMN,APP_DEBUG,"%s: i=%d packInt=%X\n",__func__,packInt);  */

        // Truncate extra bit if necessary
        if ( inSignificantBit > 0 ) {
            discard(arrayPtr, wordSize, inSignificantBit, currentWord, bitPackInFirstWord);
        }

        if ( ( hasMissing == 1 ) && ( packInt == missingToken ) ) {
            arrayOfFloat[i] = missingValueTag;
        } else if ( packInt == 0 ) {
            arrayOfFloat[i] = minFloat;
        } else {
            arrayOfFloat[i] = (packInt  *  mulFactor) * 1.0000000000001 + minFloat;
        }

    }

    return (uint32_t *)arrayOfFloat;
}

#undef CAT
#undef PASTE
