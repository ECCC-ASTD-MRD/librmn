#include "c_fst98_interface.hf"
!
! do not include the interface to the Fortran functions if C_INTERFACE_ONLY is defined
! (used by fstd98_mod.F90 to avoid duplicate interfaces)
!
#if ! defined(C_INTERFACE_ONLY)

interface
    !> Open a RPN file
    function fstouv(iun, options) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> Options: RND, (R/O|R/W), VOLATILE, (XDF|RSF), PARALLEL
        character(len=*), intent(IN) :: options
        !> Number of records in the file
        integer :: status
    end function fstouv

    !> Close a RPN file
    function fstfrm(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return -1 On error
        integer :: status
    end function fstfrm

    !> Get the number of records in file
    function fstnbr(iun) result (nrec)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return Number of records or ERR_NO_FNOM if there is no file corresponding to the unit number provided
        integer :: nrec
    end function fstnbr

    !> Get number of valid records
    function fstnbrv(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return Number of records and the file excluding deleted records
        integer :: status
    end function fstnbrv

    !> To write all on your written data to disk
    function fstckp(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return 0 on success, error code otherwise
        integer :: status
    end function fstckp

    !> Locate the next record that matches the search keys
    function fstinf(iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> Validity date
        integer, intent(IN) :: datev
        !> Vertical level
        integer, intent(IN) :: ip1
        !> Forecast hour
        integer, intent(IN) :: ip2
        !> User defined identifier
        integer, intent(IN) :: ip3
        !> Field type
        character(len = 3), intent(IN) :: typvar
        !> Variable name
        character(len = 5), intent(IN) :: nomvar
        !> Label
        character(len = 13), intent(IN) :: etiket
        !> \return Field handle
        integer :: handle
    end function fstinf

    !> Find init record that matches the latest search keys
    function fstsui(iun, ni, nj, nk) result(handle)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> \return Field handle
        integer :: handle
    end function fstsui

    !> Locate the next records matching the search keys starting at the specified record
    function fstinfx(start, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)
        implicit none
        !> Handle of the records from where to begin the search
        integer, intent(IN), value :: start
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> Validity date
        integer, intent(IN) :: datev
        !> Vertical level
        integer, intent(IN) :: ip1
        !> Forecast hour
        integer, intent(IN) :: ip2
        !> User defined identifier
        integer, intent(IN) :: ip3
        !> Field type
        character(len = 3), intent(IN) :: typvar
        !> Variable name
        character(len = 5), intent(IN) :: nomvar
        !> Label
        character(len = 13), intent(IN) :: etiket
        !> \return Field handle
        integer :: handle
  end function fstinfx

! /***************************************************************************** 
!  *                              F S T I N L                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Locates all the records that match the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                *
!  *  OUT liste   list of handles to the records                               *
!  *  OUT infon   number of elements for the list (number of records found)    *
!  *  OUT nmax    dimension of list as given by caller                         *
!  *                                                                           * 
!  *****************************************************************************/
  function fstinl(iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, liste, infon, nmax) result(status)

    implicit none
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3, nmax
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer, intent(OUT) :: infon
    integer, dimension(nmax), intent(OUT) :: liste
    integer :: status
    character(len=5)  :: nom
    character(len=3)  :: typ
    character(len=13) :: eti
  end function fstinl
! /*****************************************************************************
!  *                              F S T P R M                                  *
!  *                                                                           *
!  *Object                                                                     *
!  *   Get all the description informations of the record.                     *
!  *                                                                           *
!  *Arguments                                                                  *
!  *                                                                           *
!  *  IN  handle  positioning information to the record                        *
!  *  OUT date    date time stamp                                              *
!  *  OUT deet    length of a time step in seconds                             *
!  *  OUT npas    time step number                                             *
!  *  OUT ni      first dimension of the data field                            *
!  *  OUT nj      second dimension of the data field                           *
!  *  OUT nk      third dimension of the data field                            * 
!  *  OUT nbits   number of bits kept for the elements of the field            * 
!  *  OUT datyp   data type of the elements                                    * 
!  *  OUT ip1     vertical level                                               * 
!  *  OUT ip2     forecast hour                                                * 
!  *  OUT ip3     user defined identifier                                      * 
!  *  OUT typvar  type of field (forecast, analysis, climatology)              * 
!  *  OUT nomvar  variable name                                                * 
!  *  OUT etiket  label                                                        * 
!  *  OUT grtyp   type of geographical projection                              * 
!  *  OUT ig1     first grid descriptor                                        * 
!  *  OUT ig2     second grid descriptor                                       * 
!  *  OUT ig3     third grid descriptor                                        * 
!  *  OUT ig4     fourth grid descriptor                                       * 
!  *  OUT swa     starting word address                                        * 
!  *  OUT lng     record length                                                * 
!  *  OUT dltf    delete flag                                                  * 
!  *  OUT ubc     unused bit count                                             * 
!  *  OUT extra1  extra parameter                                              * 
!  *  OUT extra2  extra parameter                                              * 
!  *  OUT extra3  extra parameter                                              * 
!  *                                                                           * 
!  *****************************************************************************/
  subroutine fstprm(handle, date, deet, npas, ni, nj, nk, nbits, datyp, ip1, ip2, ip3, &
                    typvar, nomvar, etiket, grtyp, &
                    ig1, ig2, ig3, ig4, swa, lng, dlft, ubc, extra1, extra2, extra3)
    implicit none
    integer, intent(IN), value :: handle
    integer, intent(OUT) :: date, deet, npas, ni, nj, nk, nbits, datyp, ip1, ip2, ip3
    integer, intent(OUT) :: ig1, ig2, ig3, ig4, swa, lng, dlft, ubc, extra1, extra2, extra3
    character(len=*), intent(OUT) :: typvar, nomvar, etiket, grtyp
  end subroutine fstprm
! /***************************************************************************** 
!  *                              F S T L I R X                                *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *   The search begins at the position given by the start handle.            * 
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field   data field to be read                                        * 
!  *  IN  start   handle from which the search begins                          *
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlirx(field, start, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun, start
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlirx
! /***************************************************************************** 
!  *                              F S T L I R                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT field   data field to be read                                        * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlir(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlir
! /***************************************************************************** 
!  *                              F S T L I R _ S                              *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT string  character string to be read                                  * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
! ftnword f77name(fstlir_s)(void *string, ftnword *f_iun,
!                         ftnword *f_ni, ftnword *f_nj,
!                         ftnword *f_nk, ftnword *f_datev, char *f_etiket,
!                         ftnword *f_ip1, ftnword *f_ip2, ftnword *f_ip3,
!                         char *f_typvar, char *f_nomvar,
!                         int lng_string, F2Cl ll1, F2Cl ll2, F2Cl ll3)
  function fstlir_s(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, lngstr) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes ,target
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3, lngstr
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlir_s
! /***************************************************************************** 
!  *                            F S T L I S                                    *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the last search criterias            *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field   data field to be read                                        * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *                                                                           * 
!  *****************************************************************************/
! int c_fstlis(word *field, int iun, int *ni, int *nj, int *nk)
! ftnword f77name(fstlis)(word *field, ftnword *f_iun,
!                         ftnword *f_ni, ftnword *f_nj, ftnword *f_nk)
  function fstlis(field, iun, ni, nj, nk) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer :: handle
  end function fstlis
! /***************************************************************************** 
!  *                             F S T L I C                                   *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Search for a record that matches the research keys and check that the   *
!  *   remaining parmeters match the record descriptors                        *
!  *                                                                           *
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field    data field to be read                                       * 
!  *  IN  iun      unit number associated to the file                          * 
!  *  IN  niin     dimension 1 of the data field                               * 
!  *  IN  njin     dimension 2 of the data field                               * 
!  *  IN  nkin     dimension 3 of the data field                               * 
!  *  IN  datev    valid date                                                  * 
!  *  IN  etiket   label                                                       * 
!  *  IN  ip1      vertical level                                              * 
!  *  IN  ip2      forecast hour                                               * 
!  *  IN  ip3      user defined identifier                                     * 
!  *  IN  typvar   type of field                                               * 
!  *  IN  nomvar   variable name                                               * 
!  *  IN  ig1      first grid descriptor                                       * 
!  *  IN  ig2      second grid descriptor                                      * 
!  *  IN  ig3      third grid descriptor                                       * 
!  *  IN  ig4      fourth grid descriptor                                      * 
!  *  IN  grtyp    type of geographical projection                             * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlic(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, &
                  ig1, ig2, ig3, ig4, grtyp) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
    integer, intent(IN)  :: ig1, ig2, ig3, ig4
    integer :: handle
  end function fstlic

! /***************************************************************************** 
!  *                              F S T E C R                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Writes a record into a file.                                                  *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  field   field to write to the file                                   * 
!  *  IN  work    work field (kept for backward compatibility)                 * 
!  *  IN  npak    number of bits kept for the elements of the field (-npak)    * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  IN  date    date time stamp                                              * 
!  *  IN  deet    length of a time step in seconds                             * 
!  *  IN  npas    time step number                                             * 
!  *  IN  ni      first dimension of the data field                            * 
!  *  IN  nj      second dimension of the data field                           * 
!  *  IN  nk      third dimension of the data field                            * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field (forecast, analysis, climatology)              * 
!  *  IN  nomvar  variable name                                                * 
!  *  IN  etiket  label                                                        * 
!  *  IN  grtyp   type of geographical projection                              * 
!  *  IN  ig1     first grid descriptor                                        * 
!  *  IN  ig2     second grid descriptor                                       * 
!  *  IN  ig3     third grid descriptor                                        * 
!  *  IN  ig4     fourth grid descriptor                                       * 
!  *  IN  datyp   data type of the elements                                    * 
!  *  IN  rewrit  rewrite flag (true=rewrite existing record, false=append)    *
!  *                                                                           * 
!  *****************************************************************************/
  subroutine fstecr(field, work, npak, iun, date, deet, npas, ni, nj, nk, &
                    ip1, ip2, ip3, typvar, nomvar, etiket, &
                    grtyp, ig1, ig2, ig3, ig4, datyp, rewrite)

    implicit none
#define IgnoreTypeKindRank field, work
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(IN) :: npak, date, deet, npas, ni, nj, nk, datyp, rewrite
    integer, intent(IN) :: ip1, ip2, ip3, ig1, ig2, ig3, ig4
    character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
  end subroutine fstecr

! /***************************************************************************** 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  string  character string to write to the file                        * 
!  *  IN  work    work field (kept for backward compatibility)                 * 
!  *  IN  npak    number of bits kept for the elements of the field (-npak)    * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  IN  date    date time stamp                                              * 
!  *  IN  deet    length of a time step in seconds                             * 
!  *  IN  npas    time step number                                             * 
!  *  IN  ni      first dimension of the data field                            * 
!  *  IN  nj      second dimension of the data field                           * 
!  *  IN  nk      third dimension of the data field                            * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field (forecast, analysis, climatology)              * 
!  *  IN  nomvar  variable name                                                * 
!  *  IN  etiket  label                                                        * 
!  *  IN  grtyp   type of geographical projection                              * 
!  *  IN  ig1     first grid descriptor                                        * 
!  *  IN  ig2     second grid descriptor                                       * 
!  *  IN  ig3     third grid descriptor                                        * 
!  *  IN  ig4     fourth grid descriptor                                       * 
!  *  IN  datyp   data type of the elements                                    * 
!  *  IN  rewrit  rewrite flag (true=rewrite existing record, false=append)    *
!  *                                                                           * 
!  *****************************************************************************/
    !> Write string to file
    function fstecr_s(field, work, npak, iun, date, deet, npas, ni, nj, nk, &
                    ip1, ip2, ip3, typvar, nomvar, etiket, &
                    grtyp, ig1, ig2, ig3, ig4, datyp, rewrite, lngstr) result(status)

        implicit none
#define IgnoreTypeKindRank field, work
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
        integer, intent(IN), value :: iun
        integer, intent(IN) :: npak, date, deet, npas, ni, nj, nk, datyp, rewrite
        integer, intent(IN) :: ip1, ip2, ip3, ig1, ig2, ig3, ig4, lngstr
        character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
        integer :: status
    end function fstecr_s

    !> \copydoc c_fsteff
    function fsteff(handle) result (status)
        implicit none
        !> Handle to the record to delete
        integer, intent(IN), value :: handle
        !> 0 on success, error code otherwise
        integer :: status
    end function fsteff

    !> \copydoc c_fstluk
    function fstluk(field, handle, ni, nj, nk) result(handle_out)
        implicit none
        !> \param[out] field Data field to be read
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
        !> Handle of the field to be read
        integer, intent(IN), value :: handle
        !> First dimension of the data field
        integer, intent(OUT) :: ni
        !> Second dimension of the data field
        integer, intent(OUT) :: nj
        !> Third dimension of the data field
        integer, intent(OUT) :: nk
        !> \return Field handle
        integer :: handle_out
    end function fstluk

    !> \copydoc c_fstlnk
    function fstlnk(link_list,n) result(status) bind(C,name='c_fstlnk')
        implicit none
        !> List of unit numbers associated to the files
        integer, dimension(n) :: link_list
        !> Number of files to link
        integer, intent(IN), value :: n
        integer :: status
    end function fstlnk

    !> \copydoc c_fstunl
    function fstunl() result(status) bind(C,name='c_fstunl')
        implicit none
        integer :: status
    end function fstunl

    !> \copydoc c_fst_data_length
    function fst_data_length(length_type) result(status)
        implicit none
        !> Data length and kind
        !> | length_type | Description       |
        !> | ----------: | :---------------- |
        !> |           1 | Byte              |
        !> |           2 | Short (16 bits)   |
        !> |           3 | Regular (32 bits) |
        !> |           4 | Double (64 bits)  |
        integer, intent(IN), value :: length_type
        !> Always 0
        integer :: status
    end function fst_data_length

    !> Mask a portion of the search keys
    function fstmsq(iun, mip1, mpi2, mpi3, metiket, getmode) result(status)
        implicit none
        !> File unit number
        integer, intent(IN), value :: iun
        !> Mask for vertical level
        integer, intent(INOUT) :: mip1
        !> Mask for forecast hour
        integer, intent(INOUT) :: mpi2
        !> Mask for ip3 (user defined identifier)
        integer, intent(INOUT) :: mpi3
        !> Mask for label
        character(len=*), intent(INOUT) :: metiket
        !> Operation mode (1: get, 0: set)
        integer, intent(IN), value :: getmode
        !> \return 0 on success, error code otherwise
        integer :: status
    end function fstmsq

    !> Generates all possible coded ip1 values for a given level
    function ip1_all(level, vkind) result(ip_new)
        implicit none
        !> IP1 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip_plus
        integer, intent(IN), value :: vkind
        integer :: ip_new
    end function ip1_all

    !> Generate all possible coded ip2 values for a given level
    function ip2_all(level, vkind) result(ip_new)
        implicit none
        !> IP2 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip
        integer, intent(IN), value :: vkind
        integer :: ip_new
    end function ip2_all

    !> Generate all possible coded ip3 values
    function ip3_all(level, vkind) result(ip_new)
        implicit none
        !> IP3 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip
        integer, intent(IN), value :: vkind
        integer :: ip_new
    end function ip3_all

    !> Generate coded ip1 value for a given level (shorthand for convip)
    function ip1_val(level, vkind) result(ip_new)
        implicit none
        !> ip1 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip_plus
        integer, intent(IN), value :: vkind
        !> \return Encoded IP1 value
        integer :: ip_new
    end function ip1_val

    !> Generate coded ip2 value for a given level (shorthand for convip)
    function ip2_val(level, vkind) result(ip_new)
        implicit none
        !> IP2 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip
        integer, intent(IN), value :: vkind
        !> \return Encoded IP2 value
        integer :: ip_new
    end function ip2_val

    !> Generates coded ip3 value for a ip3 (shorthand for convip)
    function ip3_val(level, vkind) result(ip_new)
        implicit none
        !> IP3 level (float value)
        real, intent(IN), value :: level
        !> Level kind as defined in convip
        integer, intent(IN), value :: vkind
        !> \return Encoded IP3 value
        integer :: ip_new
    end function ip3_val

    !> Checks if an RPN standard file is valid
    function fstcheck(path) result(status)
        implicit none
        !> Path of the file to check
        character(len = *), intent(IN) :: path
        !> \return 0 when valid; -1 otherwise
        integer :: status
    end function fstcheck

    !> Reset all the flags previously set by ip(1-3)_val
    subroutine fstreset_ip_flags()
    end subroutine fstreset_ip_flags

    !> Rewinds a RPN standard sequential file
    function fstrwd(iun) result(status)
        implicit none
        !> Unit number associated to the file
        integer, intent(IN), value :: iun
        integer :: status
    end function fstrwd

    !> Skip nrec records forward or backward in the sequential file
    function fstskp(iun, nrec) result(status)
        implicit none
        !> Unit number associated to the file
        integer, intent(IN), value :: iun
        !> Number of records to skip (negative nrec means backward)
        integer, intent(IN), value :: nrec
        !> \return 0 on success, error code otherwise
        integer :: status
    end function fstskp

    !> Get version number
    function fst_version() result(version)
        implicit none
        !> \return Version number
        integer :: version
    end function fst_version

    !> Print directory content of the file
    function fstvoi(iun, options) result(status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> 'NEWSTYLE' or 'SHORT'. The default is the long format which includes ig*
        character(len=*), intent(IN) :: options
        !> \return 0 on success, non-zero error code otherwise
        integer :: status
    end function fstvoi

    !> Write a logical end of file
    function fstweo(iun, level) result(status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> Level of logical end of file [1, 14]
        integer, intent(IN), value :: level
        !> \return 0 on success, non-zero error code otherwise
        integer :: status
    end function fstweo

    !> Position at the end of a sequential file for an append
    function fstapp(iun, option) result(status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> Unused; kept for backward compatibility
        character(len=*), intent(IN) :: option
        !> \return 0 on success, non-zero error code otherwise
        integer :: status
    end function fstapp
end interface

! generic interface for options
interface fstoption
    !> Print out or set a fstd or xdf global variable option
    function fstopi(option, val, getmode) result(status)
        implicit none
        !> Option name to be set/printed
        character(len=*), intent(IN) :: option
        !> Option value
        integer, intent(IN), value :: val
        integer, intent(IN), value :: getmode
        !> Operation mode (1: print option, 0: set option, 2: get option)
        integer :: status
    end function fstopi

    !> Print, get, or set a fstd or xdf global option
    function fstopl(option, val, getmode) result(status)
        implicit none
        !> Option name (FASTIO, IMAGE, REDUCTION32)
        character(len=*), intent(IN) :: option
        !> Value
        logical, intent(IN), value :: val
        !> Operation mode (1: print option, 0: set option, 2: get option)
        integer, intent(IN), value :: getmode
        !> Value if getmode = 2, 0 on success for other modes or error code
        integer :: status
    end function fstopl

    !> Print, get, or set a fstd or xdf REAL global option
    function fstopr(option, val, getmode) result(status)
        !> Currently there are no REAL options!
        implicit none
        !> Option name
        character(len=*), intent(IN) :: option
        !> Value
        real, intent(IN), value :: val
        !> Operation mode (0: set option, 1: print option, 2: get option)
        integer, intent(IN), value :: getmode
        !> 0 on success, error code otherwise
        integer :: status
    end function fstopr

    !> Print, get, or set a fstd or xdf global option
    function fstopc(option, val, getmode) result(varVal)
        implicit none
        !> Option name
        character(len=*), intent(IN) :: option
        !> Value
        character(len=*), intent(IN) :: val
        !> Operation mode (0: set option, 1: print option, 2: get option)
        integer, intent(IN), value :: getmode
        !> \return Value of the variable if getmode = 2
        integer :: varVal
    end function fstopc
end interface

#endif
