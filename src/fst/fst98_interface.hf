#include "c_fst98_interface.hf"
!
! do not include the interface to the Fortran functions if C_INTERFACE_ONLY is defined
! (used by fstd98_mod.F90 to avoid duplicate interfaces)
!
#if ! defined(C_INTERFACE_ONLY)

interface
    !> Open a RPN file
    function fstouv(iun, options) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> Options: RND, (R/O|R/W), VOLATILE, (XDF|RSF), PARALLEL
        character(len=*), intent(IN) :: options
        !> Number of records in the file
        integer :: status
    end function fstouv

    !> Close a RPN file
    function fstfrm(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return -1 On error
        integer :: status
    end function fstfrm

    !> Get the number of records in file
    function fstnbr(iun) result (nrec)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return Number of records or ERR_NO_FNOM if there is no file corresponding to the unit number provided
        integer :: nrec
    end function fstnbr

    !> Get number of valid records
    function fstnbrv(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return Number of records and the file excluding deleted records
        integer :: status
    end function fstnbrv

    !> To write all on your written data to disk
    function fstckp(iun) result (status)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> \return 0 on success, error code otherwise
        integer :: status
    end function fstckp

    !> Locate the next record that matches the search keys
    function fstinf(iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> Validity date
        integer, intent(IN) :: datev
        !> Vertical level
        integer, intent(IN) :: ip1
        !> Forecast hour
        integer, intent(IN) :: ip2
        !> User defined identifier
        integer, intent(IN) :: ip3
        !> Field type
        character(len = 3), intent(IN) :: typvar
        !> Variable name
        character(len = 5), intent(IN) :: nomvar
        !> Label
        character(len = 13), intent(IN) :: etiket
        !> \return Field handle
        integer :: handle
    end function fstinf

    !> Find init record that matches the latest search keys
    function fstsui(iun, ni, nj, nk) result(handle)
        implicit none
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> \return Field handle
        integer :: handle
    end function fstsui

    !> Locate the next records matching the search keys starting at the specified record
    function fstinfx(start, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)
        implicit none
        !> Handle of the records from where to begin the search
        integer, intent(IN), value :: start
        !> Unit number of the file
        integer, intent(IN), value :: iun
        !> First dimension of the field found
        integer, intent(OUT) :: ni
        !> Second dimension of the field found
        integer, intent(OUT) :: nj
        !> Third dimension of the field found
        integer, intent(OUT) :: nk
        !> Validity date
        integer, intent(IN) :: datev
        !> Vertical level
        integer, intent(IN) :: ip1
        !> Forecast hour
        integer, intent(IN) :: ip2
        !> User defined identifier
        integer, intent(IN) :: ip3
        !> Field type
        character(len = 3), intent(IN) :: typvar
        !> Variable name
        character(len = 5), intent(IN) :: nomvar
        !> Label
        character(len = 13), intent(IN) :: etiket
        !> \return Field handle
        integer :: handle
  end function fstinfx

! /***************************************************************************** 
!  *                              F S T I N L                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Locates all the records that match the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                *
!  *  OUT liste   list of handles to the records                               *
!  *  OUT infon   number of elements for the list (number of records found)    *
!  *  OUT nmax    dimension of list as given by caller                         *
!  *                                                                           * 
!  *****************************************************************************/
  function fstinl(iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, liste, infon, nmax) result(status)

    implicit none
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3, nmax
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer, intent(OUT) :: infon
    integer, dimension(nmax), intent(OUT) :: liste
    integer :: status
    character(len=5)  :: nom
    character(len=3)  :: typ
    character(len=13) :: eti
  end function fstinl
! /*****************************************************************************
!  *                              F S T P R M                                  *
!  *                                                                           *
!  *Object                                                                     *
!  *   Get all the description informations of the record.                     *
!  *                                                                           *
!  *Arguments                                                                  *
!  *                                                                           *
!  *  IN  handle  positioning information to the record                        *
!  *  OUT date    date time stamp                                              *
!  *  OUT deet    length of a time step in seconds                             *
!  *  OUT npas    time step number                                             *
!  *  OUT ni      first dimension of the data field                            *
!  *  OUT nj      second dimension of the data field                           *
!  *  OUT nk      third dimension of the data field                            * 
!  *  OUT nbits   number of bits kept for the elements of the field            * 
!  *  OUT datyp   data type of the elements                                    * 
!  *  OUT ip1     vertical level                                               * 
!  *  OUT ip2     forecast hour                                                * 
!  *  OUT ip3     user defined identifier                                      * 
!  *  OUT typvar  type of field (forecast, analysis, climatology)              * 
!  *  OUT nomvar  variable name                                                * 
!  *  OUT etiket  label                                                        * 
!  *  OUT grtyp   type of geographical projection                              * 
!  *  OUT ig1     first grid descriptor                                        * 
!  *  OUT ig2     second grid descriptor                                       * 
!  *  OUT ig3     third grid descriptor                                        * 
!  *  OUT ig4     fourth grid descriptor                                       * 
!  *  OUT swa     starting word address                                        * 
!  *  OUT lng     record length                                                * 
!  *  OUT dltf    delete flag                                                  * 
!  *  OUT ubc     unused bit count                                             * 
!  *  OUT extra1  extra parameter                                              * 
!  *  OUT extra2  extra parameter                                              * 
!  *  OUT extra3  extra parameter                                              * 
!  *                                                                           * 
!  *****************************************************************************/
  subroutine fstprm(handle, date, deet, npas, ni, nj, nk, nbits, datyp, ip1, ip2, ip3, &
                    typvar, nomvar, etiket, grtyp, &
                    ig1, ig2, ig3, ig4, swa, lng, dlft, ubc, extra1, extra2, extra3)
    implicit none
    integer, intent(IN), value :: handle
    integer, intent(OUT) :: date, deet, npas, ni, nj, nk, nbits, datyp, ip1, ip2, ip3
    integer, intent(OUT) :: ig1, ig2, ig3, ig4, swa, lng, dlft, ubc, extra1, extra2, extra3
    character(len=*), intent(OUT) :: typvar, nomvar, etiket, grtyp
  end subroutine fstprm
! /***************************************************************************** 
!  *                              F S T L I R X                                *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *   The search begins at the position given by the start handle.            * 
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field   data field to be read                                        * 
!  *  IN  start   handle from which the search begins                          *
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlirx(field, start, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun, start
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlirx
! /***************************************************************************** 
!  *                              F S T L I R                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT field   data field to be read                                        * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlir(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlir
! /***************************************************************************** 
!  *                              F S T L I R _ S                              *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the research keys.                   *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT string  character string to be read                                  * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *  IN  datev   valid date                                                   * 
!  *  IN  etiket  label                                                        * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field                                                * 
!  *  IN  nomvar  variable name                                                * 
!  *                                                                           * 
!  *****************************************************************************/
! ftnword f77name(fstlir_s)(void *string, ftnword *f_iun,
!                         ftnword *f_ni, ftnword *f_nj,
!                         ftnword *f_nk, ftnword *f_datev, char *f_etiket,
!                         ftnword *f_ip1, ftnword *f_ip2, ftnword *f_ip3,
!                         char *f_typvar, char *f_nomvar,
!                         int lng_string, F2Cl ll1, F2Cl ll2, F2Cl ll3)
  function fstlir_s(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, lngstr) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes ,target
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3, lngstr
    character(len=*), intent(IN) :: typvar, nomvar, etiket
    integer :: handle
  end function fstlir_s
! /***************************************************************************** 
!  *                            F S T L I S                                    *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Reads the next record that matches the last search criterias            *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field   data field to be read                                        * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *                                                                           * 
!  *****************************************************************************/
! int c_fstlis(word *field, int iun, int *ni, int *nj, int *nk)
! ftnword f77name(fstlis)(word *field, ftnword *f_iun,
!                         ftnword *f_ni, ftnword *f_nj, ftnword *f_nk)
  function fstlis(field, iun, ni, nj, nk) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer :: handle
  end function fstlis
! /***************************************************************************** 
!  *                             F S T L I C                                   *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Search for a record that matches the research keys and check that the   *
!  *   remaining parmeters match the record descriptors                        *
!  *                                                                           *
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field    data field to be read                                       * 
!  *  IN  iun      unit number associated to the file                          * 
!  *  IN  niin     dimension 1 of the data field                               * 
!  *  IN  njin     dimension 2 of the data field                               * 
!  *  IN  nkin     dimension 3 of the data field                               * 
!  *  IN  datev    valid date                                                  * 
!  *  IN  etiket   label                                                       * 
!  *  IN  ip1      vertical level                                              * 
!  *  IN  ip2      forecast hour                                               * 
!  *  IN  ip3      user defined identifier                                     * 
!  *  IN  typvar   type of field                                               * 
!  *  IN  nomvar   variable name                                               * 
!  *  IN  ig1      first grid descriptor                                       * 
!  *  IN  ig2      second grid descriptor                                      * 
!  *  IN  ig3      third grid descriptor                                       * 
!  *  IN  ig4      fourth grid descriptor                                      * 
!  *  IN  grtyp    type of geographical projection                             * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlic(field, iun, ni, nj, nk, datev, etiket, ip1, ip2, ip3, typvar, nomvar, &
                  ig1, ig2, ig3, ig4, grtyp) result(handle)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(OUT) :: ni, nj, nk
    integer, intent(IN)  :: datev, ip1, ip2, ip3
    character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
    integer, intent(IN)  :: ig1, ig2, ig3, ig4
    integer :: handle
  end function fstlic

! /***************************************************************************** 
!  *                              F S T E C R                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Writes a record into a file.                                                  *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  field   field to write to the file                                   * 
!  *  IN  work    work field (kept for backward compatibility)                 * 
!  *  IN  npak    number of bits kept for the elements of the field (-npak)    * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  IN  date    date time stamp                                              * 
!  *  IN  deet    length of a time step in seconds                             * 
!  *  IN  npas    time step number                                             * 
!  *  IN  ni      first dimension of the data field                            * 
!  *  IN  nj      second dimension of the data field                           * 
!  *  IN  nk      third dimension of the data field                            * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field (forecast, analysis, climatology)              * 
!  *  IN  nomvar  variable name                                                * 
!  *  IN  etiket  label                                                        * 
!  *  IN  grtyp   type of geographical projection                              * 
!  *  IN  ig1     first grid descriptor                                        * 
!  *  IN  ig2     second grid descriptor                                       * 
!  *  IN  ig3     third grid descriptor                                        * 
!  *  IN  ig4     fourth grid descriptor                                       * 
!  *  IN  datyp   data type of the elements                                    * 
!  *  IN  rewrit  rewrite flag (true=rewrite existing record, false=append)    *
!  *                                                                           * 
!  *****************************************************************************/
  subroutine fstecr(field, work, npak, iun, date, deet, npas, ni, nj, nk, &
                    ip1, ip2, ip3, typvar, nomvar, etiket, &
                    grtyp, ig1, ig2, ig3, ig4, datyp, rewrite)

    implicit none
#define IgnoreTypeKindRank field, work
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(IN) :: npak, date, deet, npas, ni, nj, nk, datyp, rewrite
    integer, intent(IN) :: ip1, ip2, ip3, ig1, ig2, ig3, ig4
    character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
  end subroutine fstecr
! /***************************************************************************** 
!  *                              F S T E C R _ S                              *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Writes record to file.                                                  *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  string  character string to write to the file                        * 
!  *  IN  work    work field (kept for backward compatibility)                 * 
!  *  IN  npak    number of bits kept for the elements of the field (-npak)    * 
!  *  IN  iun     unit number associated to the file                           * 
!  *  IN  date    date time stamp                                              * 
!  *  IN  deet    length of a time step in seconds                             * 
!  *  IN  npas    time step number                                             * 
!  *  IN  ni      first dimension of the data field                            * 
!  *  IN  nj      second dimension of the data field                           * 
!  *  IN  nk      third dimension of the data field                            * 
!  *  IN  ip1     vertical level                                               * 
!  *  IN  ip2     forecast hour                                                * 
!  *  IN  ip3     user defined identifier                                      * 
!  *  IN  typvar  type of field (forecast, analysis, climatology)              * 
!  *  IN  nomvar  variable name                                                * 
!  *  IN  etiket  label                                                        * 
!  *  IN  grtyp   type of geographical projection                              * 
!  *  IN  ig1     first grid descriptor                                        * 
!  *  IN  ig2     second grid descriptor                                       * 
!  *  IN  ig3     third grid descriptor                                        * 
!  *  IN  ig4     fourth grid descriptor                                       * 
!  *  IN  datyp   data type of the elements                                    * 
!  *  IN  rewrit  rewrite flag (true=rewrite existing record, false=append)    *
!  *                                                                           * 
!  *****************************************************************************/
  function fstecr_s(field, work, npak, iun, date, deet, npas, ni, nj, nk, &
                    ip1, ip2, ip3, typvar, nomvar, etiket, &
                    grtyp, ig1, ig2, ig3, ig4, datyp, rewrite, lngstr) result(status)

    implicit none
#define IgnoreTypeKindRank field, work
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: iun
    integer, intent(IN) :: npak, date, deet, npas, ni, nj, nk, datyp, rewrite
    integer, intent(IN) :: ip1, ip2, ip3, ig1, ig2, ig3, ig4, lngstr
    character(len=*), intent(IN) :: typvar, nomvar, etiket, grtyp
    integer :: status
  end function fstecr_s
! /***************************************************************************** 
!  *                             F S T E F F                                   *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Deletes the record associated to handle.                                *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  handle  handle to the record to delete                               * 
!  *                                                                           * 
!  *****************************************************************************/
  function fsteff(handle) result (status)

    implicit none
    integer, intent(IN), value :: handle
    integer :: status
  end function fsteff

! /***************************************************************************** 
!  *                              F S T L U K                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Read the record at position given by handle.                            *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  OUT field   data field to be read                                        * 
!  *  IN  handle  positioning information to the record                        * 
!  *  OUT ni      dimension 1 of the data field                                * 
!  *  OUT nj      dimension 2 of the data field                                * 
!  *  OUT nk      dimension 3 of the data field                                * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstluk(field, handle, ni, nj, nk) result(handle_out)

    implicit none
#define IgnoreTypeKindRank field
#define ExtraAttributes 
#include <IgnoreTypeKindRank.hf>
    integer, intent(IN), value :: handle
    integer, intent(OUT) :: ni, nj, nk
    integer :: handle_out
  end function fstluk

! /***************************************************************************** 
!  *                              F S T L N K                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Links a list of files together for search purpose.                      *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  liste   list of unit numbers associated to the files                 * 
!  *  IN  n       number of files to link                                      * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstlnk(link_list,n) result(status) bind(C,name='c_fstlnk')

    implicit none
    integer, intent(IN), value :: n
    integer, dimension(n) :: link_list
    integer :: status
  end function fstlnk

!  /***************************************************************************** 
!  *                              F S T U N L                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Unlinks a list of files previously linked by fstlnk.                    *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  liste   list of unit numbers associated to the files                 * 
!  *  IN  n       number of files to link                                      * 
!  *                                                                           * 
!  *****************************************************************************/
  function fstunl() result(status) bind(C,name='c_fstunl')

    implicit none
    integer :: status
  end function fstunl

! /***************************************************************************** 
!  *                      F S T _ D A T A _ L E N G T H                        *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Gives information on data lenght of the elements passed to fstecr       *
!  *   and fstlir (double, short integer, byte ...)                            *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  length_type     data length kind                                     * 
!  *                      1: byte                                              *
!  *                      2: short (16 bits)                                   *
!  *                      4: regular 32 bits                                   *
!  *                      8: double (64 bits)                                  *
!  *                                                                           * 
!  *****************************************************************************/
  function fst_data_length(l) result(status)

    implicit none
    integer, intent(IN), value :: l
    integer :: status
  end function fst_data_length

! /***************************************************************************** 
!  *                            F S T M S Q                                    *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Mask a portion of the research keys.                                    *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *   IN    iun     unit number associated to the file                        * 
!  * IN/OUT  mip1    mask for vertical level                                   * 
!  * IN/OUT  mip2    mask for forecast hour                                    * 
!  * IN/OUT  mip3    mask for ip3 (user defined identifier)                    * 
!  * IN/OUT  metiket mask for label                                            * 
!  *   IN    getmode logical (1: getmode 0:set mode)                           * 
!  *                                                                           * 
!  *****************************************************************************/
! ftnword f77name(fstmsq)(ftnword *f_iun, ftnword *f_mip1, ftnword *f_mip2,
!                         ftnword *f_mip3, char *f_metiket, ftnword *f_getmode,
! int c_fstmsq(int iun, int *mip1, int *mip2, int *mip3, char *metiket,
!                      int getmode)
  function fstmsq(iun, mip1, mpi2, mpi3, metiket, getmode) result(status)

      implicit none
      integer, intent(IN), value :: iun, getmode
      integer, intent(INOUT) :: mip1, mpi2, mpi3
      character(len=*), intent(INOUT) :: metiket
      integer :: status
  end function fstmsq
! /***************************************************************************** 
!  *                             I P n _ A L L                                 *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Generates all possible coded ip1 values for a given level               *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  level          ip1 level (float value)                               * 
!  *  IN  kind           level kind as defined in convip_plus                  * 
!  *                                                                           * 
!  *****************************************************************************/

    function ip1_all(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip1_all
    function ip2_all(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip2_all
    function ip3_all(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip3_all

! /***************************************************************************** 
!  *                             I P n _ V A L                                 *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Generates all possible coded ip1 values for a given level               *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *  IN  level          ip1 level (float value)                               * 
!  *  IN  kind           level kind as defined in convip_plus                  * 
!  *                                                                           * 
!  *****************************************************************************/

    function ip1_val(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip1_val
    function ip2_val(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip2_val
    function ip3_val(level, vkind) result(ip_new)

      implicit none
      real, intent(IN), value :: level
      integer, intent(IN), value :: vkind
      integer :: ip_new
    end function ip3_val

    !> Checks if an RPN standard file is valid
    function fstcheck(path) result(status)
      implicit none
      !> Path of the file to check
      character(len = *), intent(IN) :: path
      !> \return 0 when valid; -1 otherwise
      integer :: status
    end function fstcheck

    !> Reset all the flags previously set by ip(1-3)_val
    subroutine fstreset_ip_flags()
    end subroutine fstreset_ip_flags

    !> Rewinds a RPN standard sequential file
    function fstrwd(iun) result(status)
      implicit none
      !> Unit number associated to the file
      integer, intent(IN), value :: iun
      integer :: status
    end function fstrwd

    !> Skip nrec records forward or backward in the sequential file
    function fstskp(iun, nrec) result(status)
      implicit none
      !> Unit number associated to the file
      integer, intent(IN), value :: iun
      !> Number of records to skip (negative nrec means backward)
      integer, intent(IN), value :: nrec
      !> \return 0 on success, error code otherwise
      integer :: status
    end function fstskp

    !> Get version number
    function fst_version() result(version)
      implicit none
      !> \return Version number
      integer :: version
    end function fst_version

    !> Print directory content of the file
    function fstvoi(iun, options) result(status)
      implicit none
      !> Unit number of the file
      integer, intent(IN), value :: iun
      !> 'NEWSTYLE' or 'SHORT'. The default is the long format which includes ig*
      character(len=*), intent(IN) :: options
      !> \return 0 on success, non-zero error code otherwise
      integer :: status
    end function fstvoi

    !> Write a logical end of file
    function fstweo(iun, level) result(status)
      implicit none
      !> Unit number of the file
      integer, intent(IN), value :: iun
      !> Level of logical end of file [1, 14]
      integer, intent(IN), value :: level
      !> \return 0 on success, non-zero error code otherwise
      integer :: status
    end function fstweo

    !> Position at the end of a sequential file for an append
    function fstapp(iun, option) result(status)
      implicit none
      !> Unit number of the file
      integer, intent(IN), value :: iun
      !> Unused; kept for backward compatibility
      character(len=*), intent(IN) :: option
      !> \return 0 on success, non-zero error code otherwise
      integer :: status
    end function fstapp
end interface

! generic interface for options
interface fstoption

!  /*****************************************************************************
!  *                              F S T O P I                                  *
!  *                                                                           * 
!  *Object                                                                     * 
!  *   Print out or set a fstd or xdf global variable option.                  *
!  *                                                                           * 
!  *Arguments                                                                  * 
!  *                                                                           * 
!  *   IN     option   option name to be set/printed                           * 
!  *   IN     value    option value                                            * 
!  *   IN     getmode  logical (1: get option, 0: set option)                  * 
!  *                                                                           * 
!  *****************************************************************************/

    function fstopi(option, val, getmode) result(status)

      implicit none
      character(len=*), intent(IN) :: option
      integer, intent(IN), value :: val, getmode
      integer :: status
    end function fstopi

    !> Print, get, or set a fstd or xdf global option
    function fstopl(option, val, getmode) result(status)
        implicit none
        !> Option name (FASTIO, IMAGE, REDUCTION32)
        character(len=*), intent(IN) :: option
        !> Value
        logical, intent(IN), value :: val
        !> Operation mode (1: print option, 0: set option, 2: get option)
        integer, intent(IN), value :: getmode
        !> Value if getmode = 2, 0 on success for other modes or error code
        integer :: status
    end function fstopl

    !> Print, get, or set a fstd or xdf REAL global option
    function fstopr(option, val, getmode) result(status)
        !> Currently there are no REAL options!
        implicit none
        !> Option name
        character(len=*), intent(IN) :: option
        !> Value
        real, intent(IN), value :: val
        !> Operation mode (0: set option, 1: print option, 2: get option)
        integer, intent(IN), value :: getmode
        !> 0 on success, error code otherwise
        integer :: status
    end function fstopr

    !> Print, get, or set a fstd or xdf global option
    function fstopc(option, val, getmode) result(varVal)
        implicit none
        !> Option name
        character(len=*), intent(IN) :: option
        !> Value
        character(len=*), intent(IN) :: val
        !> Operation mode (0: set option, 1: print option, 2: get option)
        integer, intent(IN), value :: getmode
        !> \return Value of the variable if getmode = 2
        integer :: varVal
    end function fstopc
end interface

#endif
