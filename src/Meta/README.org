* Introduction
- The new metadata now available in FST23 allows the storage of much more information while being flexible, extensible and future proof.
- This metadata is in addition to the previous indexable metadata already available (NOMVAR,TYPVAR,IP,...) and will keep backward compatibility with previous FST89 and FST98.
- It uses a grammar for token/value pair definitions implemented as JSON, and versionned through JSON profiles. 
- Management of the profiles and accetpted value pair shall be managed by the [[https://wiki.cmc.ec.gc.ca/wiki/Comit%C3%A9_de_gouvernance_des_donn%C3%A9es_du_CMC][Data Governance Commitee (DGC/CGD)]]

* Environment variable
- META_VERSION  : Version of metadata to be used (Default: latest)
- META_VALIDATE : Enable validation of json values (default: FALSE)
- ARMNLIB       : Use to find location of metadata templates ans definitions ($ARMNLIB/json/${META_VERSION})

* Grammar
** Field level metadata and FST98 RPN correspondance

| RPN          | Extended metadata                                                         |                            
|--------------+--------------------------------------------------------------|
|              |version = [semantic version]                                  |
|              |standard_name = [cf convention]                               |
|NOMVAR        |rpn_name = [dict]                                             |
|              |long_name = "…“                                               |
|              |description ="…"                                              |
|              |bounds= [lower(double)] [higher(double)] [vertical reference] |
|              |units = [udunits]                                             |
|NI.NJ,NK      |size=[ni,nj,nk]                                               |
|GRTYP         |horizontal_reference= [horizontal reference]                  |
|IP2-3         |cell_methods = [cell_method]*                                 |
|              |missing_values = [reason value]*                              |
|              |mask = "…"                                                    |
|IP1           |level = value [level_def]                                     |
|ETIKET+TYPVAR |qualifiers = [qualifier]*                                     |
|DATEO         |forecast_reference_datetime = [datetime]                      |
|DATEV         |forecast_datetime  = [datetime]                               |
|DEET+NPAS     |forecast_period = [size time_unit step]                       |
|NPACK         |type = [datatype]                                             |
|              |size = [type nbits]                                           |
|              |pack = [packing nbits]                                        |
|              |compression = [compression_type]                              |
  
- axis          = [time, level, latitude, longitude, x, y, z]
- process       = [average, sum, minimum, maximum, median, standard_deviation, error, …]
- time_unit     = [seconds, minutes, hours, days, weeks, years, ...]
- datetime      = ISO8601 formatted, but seconds internally
- qualifier     = [analysis, climatology, raw_station, error, constants, verification_matrix, observation, prognostic, diagnostic, analysis_increment, scores, timeseries, operational, parallel, experimental, member:n, centile[<,<=,=,>,>=]value, …]
- unit          = [udunit] | [time_unit] 
- filter        = [gaussian, …] 
- interpolator  = [nearest, linear, cubic, …]
- cell_method   = interpolation:[interpolator] | filter:[filter] | [axis]:[process]([interval [n]|[value_0 value_1] [unit])*

(For all accepted and up to date values of these parameters see $ARMNLIB/json/[version]/definitions.json)

*** json template 0.1.0
#+begin_src JSON
{  "version" : "",
   "standard_name" : "",
   "rpn_name" : "",
   "long_name" : "",
   "description" : "",
   "size" : [],
   "bounds" : {
       "min" : NaN,
       "max" : NaN
   },
   "unit" : "",
   "cell_methods" : [],
   "qualifiers" : [],
   "missing_values" : [],
   "mask"  : "",
   "vertical_level" : {
      "value" : [],
      "vertical_reference" : ""
   },
   "horizontal_reference" : "",
   "forecast_reference_datetime" : "",
   "forecast_datetime" : "",
   "forecast_period" : {
      "step"  : -1,
      "value" : NaN,
      "unit"  : ""
   },
   "data" : {
      "type" : "",
      "bits" : 0,
      "pack" : 0,
      "compression" : ""
   }
}
#+end_src

** File level

| Now                                              |                            
|--------------------------------------------------|
| version : [semantic version]                     |
| institution : "CMC"                              |
| discipline" : [climatology,meteorology,…]        |
| title" : "run id"                                |
| source" : [GDPS, RDPS, HRDPS, …][version]        |
| description" : ""                                |
| state : [Operational, parallel, experimenta, ...]|
| vertical_references" : []                        |
| horizontal_references" : []                      |

*** json template 0.1.0
#+begin_src JSON
{
   "version" : "",
   "institution" : "CMC",
   "discipline" : "",
   "title" : "",
   "source" : "",
   "state" : "",
   "description" : "",
   "vertical_references" : [],
   "horizontal_references" : []
}
#+end_src


* Code example
** C
#+BEGIN_SRC C
#include <rmn/Meta.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {

   json_object *prof_file=NULL,*prof_fld=NULL;
   double levels[1]= { 1000.0 };

   if (!Meta_Init()) exit(EXIT_FAILURE);

   // Load metadata template
   prof_fld=Meta_LoadProfile("field",NULL);
   prof_file=Meta_LoadProfile("file",NULL);

   // Define file metadata
   Meta_DefFile(prof_file,"CMC","Weather","G100","GDPS-5.2.0","Global forecast at 15km","Operational");
   Meta_AddHorizontalRef(prof_file,"RPN_GDPS_2020_25KM",TRUE);
   Meta_AddVerticalRef(prof_file,"PRESSURE",TRUE);

   fprintf(stderr,"File JSON: %s\n",Meta_Stringify(prof_file));

   // Define field metadata
   Meta_DefVar(prof_fld,"air_temperature","TT","air temperature","Air temperature is the bulk temperature of the air, not the surface (skin) temperature");
   Meta_DefBound(prof_fld,-60,50,"celsius");
   Meta_DefForecastTime(prof_fld,1672556400,2,60,"second");
   Meta_DefHorizontalRef(prof_fld,"RPN_GDPS_2020_25KM",FALSE);
   Meta_DefVerticalRef(prof_fld,"PRESSURE",levels,1,FALSE);
   Meta_AddCellMethod(prof_fld,"interpolation:linear");
   Meta_AddCellMethod(prof_fld,"filter:gaussian");
   Meta_AddCellMethod(prof_fld,"time:mean(interval 5 minute)");
   Meta_AddQualifier(prof_fld,"prognosis");
   Meta_AddQualifier(prof_fld,"tag:ETKGG22");
   Meta_AddQualifier(prof_fld,"member:12");
   Meta_AddQualifier(prof_fld,"centile>15");

   Meta_AddMissingValue(prof_fld,"out_of_domain",-999);

   fprintf(stderr,"Field JSON: %s\n",Meta_Stringify(prof_file));

	exit(EXIT_SUCCESS);
}
#+END_SRC

** Fortran
#+BEGIN_SRC Fortran
program meta_fortran

   use rmn_meta
   use rmn_common

   type(meta) :: meta_fld, meta_file
   type(C_PTR) obj
   real(kind=REAL64), dimension(1) :: levels = [ 1.0 ]
   integer(kind=INT32) :: ok

   call Meta_Init()
 
!   Load metadata template
   ok=meta_fld%LoadProfile("field","")
   ok=meta_file%LoadProfile("file","")

   obj=meta_file%DefFile("CMC","Weather","G100","GDPS-5.2.0","Global forecast at 15km","Operational")
   obj=meta_file%AddHorizontalRef("RPN_GDPS_2020_25KM",.true.)
   obj=meta_file%AddVerticalRef("PRESSURE",.true.)

   write(6,*) 'File JSON:',meta_file%Stringify()
 
   obj=meta_fld%DefVar("air_temperature","TT","air temperature","Air temperature is the bulk temperature of the air, not the surface (skin) temperature")
   obj=meta_fld%DefBound(-60.0d0,50.0d0,"celsius")
   obj=meta_fld%DefForecastTime(1672556400_C_LONG,2,60.0d0,"seconds")
   obj=meta_fld%DefHorizontalRef("RPN_GDPS_2020_25KM",.false.)
   obj=meta_fld%DefVerticalRef("PRESSURE",levels,1,.false.)
   obj=meta_fld%DefData(100,100,1,"float","lorenzo",16,32)
   obj=meta_fld%AddCellMethod("interpolation:linear")
   obj=meta_fld%AddCellMethod("filter:gaussian")
   obj=meta_fld%AddCellMethod("time:mean(interval 5 minute)")
   obj=meta_fld%AddQualifier("prognosis")
   obj=meta_fld%AddQualifier("tag:ETKGG22");
   obj=meta_fld%AddQualifier("member:12")
   obj=meta_fld%AddQualifier("centile>75")

   obj=meta_fld%AddMissingValue("out of domain",-999.0d0)
  
!  Output formatted
   ok=meta_fld%Resolve(meta_file);

   write(6,*) 'Field JSON:',meta_fld%Stringify()
  
end


#+END_SRC
