!!!TYPEWBFORT WB_FORTRAN_INT  TYPELEN 4 TYPE2CHAR i4 TYPEFORTRAN integer
!!!TYPEWBFORT WB_FORTRAN_INT  TYPELEN 8 TYPE2CHAR i8 TYPEFORTRAN integer*8
!!!TYPEWBFORT WB_FORTRAN_REAL TYPELEN 4 TYPE2CHAR r4 TYPEFORTRAN real
!!!TYPEWBFORT WB_FORTRAN_REAL TYPELEN 8 TYPE2CHAR r8 TYPEFORTRAN real*8
!!!TYPEWBFORT WB_FORTRAN_BOOL TYPELEN 1 TYPE2CHAR l1 TYPEFORTRAN logical
!!!TYPEWBFORT WB_FORTRAN_CHAR TYPELEN len(value) TYPE2CHAR cc TYPEFORTRAN character(len=*)

!* Code revision: $Id: whiteboard.tmpl90 955 2014-05-30 18:13:33Z armnlib $

!/* RMNLIB - Library of useful routines for C and FORTRAN programming
! * Copyright (C) 1975-2005  Environnement Canada
! *
! * This library is free software; you can redistribute it and/or
! * modify it under the terms of the GNU Lesser General Public
! * License as published by the Free Software Foundation,
! * version 2.1 of the License.
! *
! * This library is distributed in the hope that it will be useful,
! * but WITHOUT ANY WARRANTY; without even the implied warranty of
! * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! * Lesser General Public License for more details.
! *
! * You should have received a copy of the GNU Lesser General Public
! * License along with this library; if not, write to the
! * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! * Boston, MA 02111-1307, USA.
! */


!> @file Fortran Interface to the C implementation of the whiteboard

#ifdef _OPENMP
#define OMPSUFFIX _omp
#else
#define OMPSUFFIX _st
#endif

#define CAT #1#2#3#4#5#6
#define TYPELEN_SCALAR 0

#ifdef INTERFACEONLY
interface wb_get
#endif

!!@LOOP

!> Retrieve a copy of the value associated with key stored in the whiteboard saclar form
!
!> @param[in]  key   Key identifying the whiteboard entry to get
!> @param[out] value Returned value associated with key
!> @param[in]  wb    WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return WB_OK on success or error code on failure.  Use WB_IS_OK() to check.
integer function CAT(wb_get_,TYPE2CHAR,OMPSUFFIX)(key, value, wb) result(status)
    implicit none

    include "WhiteBoard.hf"

    character (len = *), intent(in) :: key
    TYPEFORTRAN, intent(out) :: value
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_get
!$omp critical
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_get(my_wb, key, TYPEWBFORT, TYPELEN, value, TYPELEN_SCALAR)
!$omp end critical
#endif
end function


!> Retrieve a copy of the value associated with key stored in the whiteboard array form
!
!> @paran[in]  key   Key identifying the whiteboard entry to get
!> @paran[out] value Returned value associated with key
!> @paran[out] nbval Number of returned values in the array
!> @paran[in]  wb    WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return WB_OK on success or error code on failure.  Use WB_IS_OK() to check.
integer function CAT(wb_get_,TYPE2CHAR,OMPSUFFIX)_a(key, value, nbval, wb) result(status)
    implicit none

    include "WhiteBoard.hf"

    character (len = *), intent(in) :: key
    TYPEFORTRAN, dimension(:), intent(out) :: value
    integer, intent(out) :: nbval
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_get
!$omp critical
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    nbval  = 0
    status = f_wb_get(my_wb, key, TYPEWBFORT, TYPELEN, value, size(value))
    if (WB_IS_OK(status)) nbval = status
!$omp end critical
!TODO: error when not enough room to get all WB values [not the default]
!!$  if present(mode0) then
!!$     if (status > size(value) .and. mode == ERR_ON_SUB_ARRAY) status = WB_ERR_WRONGDIMENSION
!!$  endif
    return
#endif
end function

!!@END

#ifdef INTERFACEONLY
end interface wb_get
#endif


#ifdef INTERFACEONLY
interface wb_put
#endif

!!@LOOP
!> Save a copy of the value in the whiteboard associated with a key name scalar form
!
!> @param[in]  key     Key identifying the whiteboard entry to set
!> @param[in]  value   Value associated with key
!> @param[in]  options Define if value is REWRITEABLE or not
!> @param[in]  wb      WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_put_,TYPE2CHAR,OMPSUFFIX)(key, value, options0, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(in), optional :: wb
    integer, intent(in), optional  :: options0
    TYPEFORTRAN, intent(in) :: value
    character (len = *), intent(in) :: key

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer :: options
    integer, external :: f_wb_put
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(options0)) then
        options = options0
    else
        options = WB_REWRITE_NONE
    endif

    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_put(my_wb, key, TYPEWBFORT, TYPELEN, value, TYPELEN_SCALAR, options)
    return
#endif
end function


!> Save a copy of the values in the whiteboard associated with a key name array form
!
!> @param[in] key      Key identifying the whiteboard entry to set
!> @param[in] value    Value associated with key
!> @param[in] options  Define if value is REWRITEABLE or not
!> @param[in] wb       WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_put_,TYPE2CHAR,_a,OMPSUFFIX)(key, value, options0, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(in), optional :: wb
    integer, intent(in), optional :: options0
    TYPEFORTRAN, dimension(:), intent(in) :: value
    character(len = *), intent(in) :: key

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer :: options
    integer, external :: f_wb_put
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (size(value) .eq. 0) then
        status = WB_ERROR
        return
    endif
    if (present(options0)) then
        options = options0
    else
        options = WB_REWRITE_NONE
    endif

    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_put(my_wb, key, TYPEWBFORT, TYPELEN, value, size(value), options)
    return
#endif
end function

!!@END

#ifdef INTERFACEONLY
end interface wb_put


interface wb_read
#endif

!> Read a dictionary or namelist into the whiteboard
!
!> @param[in] prefix_name Prefix to add to var name found in the config file as WB keyname
!> @param[in] file        Config filename to read
!> @param[in] section     Section name to read in the config file
!> @param[in] mode        Parsing mode of the config file [WB_ALLOW_DEFINE...]
!> @param[in] wb          WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_read,OMPSUFFIX)(prefix_name, file, section, mode, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    character(len = *), intent(in) :: prefix_name
    character(len = *), intent(in) :: file
    character(len = *), intent(in) :: section
    integer, intent(in) :: mode
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_read
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_read(my_wb, prefix_name, file, section, mode)
    return
#endif
end function
#ifdef INTERFACEONLY
end interface wb_read


interface wb_keys
#endif



!> Retreive all key names in the wahitboard starting with key_pattern
!
!> @param[out] keys        List of found WB key names that start with key_pattern
!> @param[out] nkeys       Number of found key name
!> @param[in]  key_pattern Key prefix to match against
!> @param[in]  wb          WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Number of matching keys found
integer function CAT(wb_keys,OMPSUFFIX)(keys, nkeys, key_pattern, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    character(len = *), intent(out) :: keys(:)
    integer, intent(out) :: nkeys
    character(len = *), intent(in) :: key_pattern
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_get_keys
!$omp critical
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    nkeys = f_wb_get_keys(my_wb, keys, size(keys), key_pattern)
    status = nkeys
!$omp endcritical
#endif
end function

#ifdef INTERFACEONLY
end interface wb_keys


interface wb_get_meta
#endif


!> Retreive meta data of WB entry conresponding to provided key name
!
!> @param[out] key        String identifying the whiteboard entry to get meta from
!> @param[out] type1      Fortran type [WB_FORTRAN_*]
!> @param[out] typelen    Length of the fortran type [4,8,len(string)]
!> @param[out] array_size Number of elements in the array; 0=scalar
!> @param[out] options    As they are set in by the put
!> @param[in]  wb         WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_get_meta,OMPSUFFIX)(key, type1, typelen, array_size, options, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    character(len = *), intent(in) :: key
    integer, intent(out) :: type1, typelen, array_size, options
    type(whiteboard), intent(in), optional :: wb


#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_get_meta
!$omp critical
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_get_meta(my_wb, key, type1, typelen, array_size, options)
!$omp end critical
#endif
end function


#ifdef INTERFACEONLY
end interface wb_get_meta

interface wb_checkpoint_setname
#endif


!> Set the name of the checkpoint file
!
!> @param[in] filename Name of the wb checkpoint file
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_checkpoint_setname,OMPSUFFIX)(filename) result(status)
    implicit none

    character(len = *), intent(in) :: filename

#ifndef INTERFACEONLY
  integer, external :: f_wb_checkpoint_name
  status = f_wb_checkpoint_name(filename)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_checkpoint_setname

interface wb_checkpoint_getname
#endif


!> Get the name of the checkpoint file
!
!> @param[out] filename Name of the wb checkpoint file
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_checkpoint_getname,OMPSUFFIX)(filename) result(status)
  implicit none

  character(len = *), intent(out) :: filename

#ifndef INTERFACEONLY
  integer, external :: f_wb_checkpoint_get_name
  status = f_wb_checkpoint_get_name(filename)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_checkpoint_getname


interface wb_checkpoint
#endif


!> Save a copy of the whiteboard to disk for re-start purpose
!
!> @param[in]  wb WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_checkpoint,OMPSUFFIX)(wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_checkpoint
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_checkpoint(my_wb)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_checkpoint


interface wb_reload
#endif


!TODO: may want to remove this and do an auto reload on 1st WB fn call

!> Force a reload of the saved copy of the whiteboard, if ant, as written by wb_checkpoint; normally done first thing on re-start
!
!> @param[in] wb WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_reload,OMPSUFFIX)(wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_reload
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_reload(my_wb)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_reload


interface wb_check
#endif


!> Check all whiteboard entries for the gien instatus, return number of entries that match
!
!> @param[in] prefix_match Prefix string to match to WB entry key name
!> @param[in] instatus     Status code to check for
!> @param[in] wb           WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Number of entries that match instatus; error if < 0
integer function CAT(wb_check,OMPSUFFIX)(prefix_match, instatus, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    character(len = *), intent(in) :: prefix_match
    integer, intent(in) :: instatus
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_check
!$omp critical
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_check(my_wb, prefix_match, instatus)
!$omp end critical
#endif
end function


#ifdef INTERFACEONLY
end interface wb_check


interface wb_lock
#endif



!> Set all whiteboard entry to WB_REWRITE_NONE if and only if key name start with prefix_match and status is WB_REWRITE_UNTIL
!
!> This is normally done after a wb_read of a config file
!
!> @param[in] prefix_match Prefix string to match to WB entry key name
!> @param[in] wb           WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_lock,OMPSUFFIX)(prefix_match, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(in), optional :: wb
    character(len = *), intent(in) :: prefix_match

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer, external :: f_wb_lock
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    status = f_wb_lock(my_wb, prefix_match)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_lock


interface wb_error_handler
#endif



!> Set error callback function
!
!> The handler_function should have the following form:
!>  subtroutine handler_function(error_severity, error_code)
!>      integer, intent(in) :: error_severity, error_code
!
!> @param[in] handler_function Error handler callback
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_error_handler,OMPSUFFIX)(handler_function) result(status)
    implicit none

    external :: handler_function

#ifndef INTERFACEONLY
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    status = WB_OK
    call f_wb_error_handler(handler_function)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_error_handler


interface wb_broadcast_init
#endif


!> Configure WhiteBoard MPI broadcasts
!
!> @return Status; use WB_IS_OK(status) to check
!
!> @param[in] pe_root :          Root procesor number to braodcast from
!> @param[in] pe_me              Actual procesor number
!> @param[in] domain             Communicator "domain" to broadcast to
!> @param[in] bcst_function      "pointer" to an mpi-like broadcast function
!> @param[in] allreduce_function "pointer" to an mpi-like allreduce function
!
!> @return Always WB_OK
integer function CAT(wb_broadcast_init,OMPSUFFIX)(pe_root, pe_me,domain, bcst_function, allreduce_function) result(status)
    implicit none

    integer, intent(in) :: pe_root, pe_me
    character(len = *) :: domain
    external :: bcst_function, allreduce_function

#ifndef INTERFACEONLY
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    status = WB_OK
    call f_wb_bcst_init(bcst_function, allreduce_function)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_broadcast_init


interface wb_broadcast
#endif


!> Perform an MPI broadcast
!
!> @param[in] key       String identifying the whiteboard entry to broadcast
!> @param[in] ispattern If not 0, key is a pattern to match
!> @param[in] wb        WhiteBoard instance.  The global instance is used if one ins't provided
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_broadcast,OMPSUFFIX)(key, ispattern, wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    character(len = *), intent(in)   :: key
    integer, intent(in), optional :: ispattern
    type(whiteboard), intent(in), optional :: wb

#ifndef INTERFACEONLY
    integer*8 :: my_wb
    integer :: ispattern0
    integer, external :: f_wb_bcst
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    if (present(wb)) then
        my_wb = wb%wb
    else
        my_wb = 0
    endif
    if (present(ispattern)) then
        ispattern0 = ispattern
    else
        ispattern0 = 0
    endif
    status = f_wb_bcst(my_wb, key, ispattern0)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_broadcast


interface wb_verbosity
#endif



!> Set the wb verbosity level
!
!> @param[in] level Verbosity level
!
!> @return The previously set verbosity level
integer function CAT(wb_verbosity,OMPSUFFIX)(level) result(status)
    implicit none

    integer, intent(in) :: level

#ifndef INTERFACEONLY
    integer, external :: f_wb_verbosity
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    status = f_wb_verbosity(level)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_verbosity

interface wb_new
#endif



!> Create a new whiteboard instance
!
!> @param[out] wb New WhiteBoard
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_new,OMPSUFFIX)(wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(out) :: wb

#ifndef INTERFACEONLY
    integer, external :: f_wb_new
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    status = f_wb_new(wb%wb)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_new

interface wb_free
#endif



!> Delete a WhiteBoard instance
!
!> @param[in] wb The WhiteBoard to delete
!
!> @return Status; use WB_IS_OK(status) to check
integer function CAT(wb_free,OMPSUFFIX)(wb) result(status)
    implicit none

    include "WhiteBoard.hf"
    type(whiteboard), intent(INOUT) :: wb

#ifndef INTERFACEONLY
    integer, external :: f_wb_free
#ifdef _OPENMP
    integer, external :: omp_get_num_threads
    if (omp_get_num_threads() > 1) then
        status = WB_ERROR
        return
    endif
#endif
    status = f_wb_free(wb%wb)
#endif
end function


#ifdef INTERFACEONLY
end interface wb_free


#endif
