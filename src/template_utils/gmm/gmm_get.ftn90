!!===================== gmm_get (interface) =====================
#ifdef INTERFACEONLY
interface gmm_get
    integer function gmm_getmeta2(iname,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        ! attributes (name in attributes is not used)
        type(gmm_metadata), intent(out) :: m
    end function gmm_getmeta2
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
    integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
        ! name (partially redundant with attributes)
        character(len=*), intent(in) :: iname
        DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
        ! attributes (name in attributes is not used)
        type(gmm_metadata), optional, intent(out) :: m
    end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
end interface

interface gmm_delete
    integer function gmm_delete(iname)
        character(len=*), intent(in) :: iname
    end function gmm_delete
end interface
#endif

#ifndef INTERFACEONLY
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none
    integer :: i, array_rank
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
    ! attributes (name in attributes is not used)
    type(gmm_metadata), optional, intent(out) :: m
    !  integer,intent(inout) :: reqid
    include 'gmm_directory_interface.inc'
    type(gmm_metadata) :: m2
    integer*8 :: key
    integer *8 get_address_from
    external get_address_from

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if(cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! return null entry
        if (present(m)) then
            m%a = GMM_NULL_ATTRIB
            m%l = GMM_NULL_LAYOUT
        endif
        nullify(p)
        key = GMM_KEY_NOT_FOUND
        Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
    else
        m2%l = directory(cur_page)%entry(cur_entry)%l
        m2%a = directory(cur_page)%entry(cur_entry)%a
        if (present(m)) then
            ! return a copy of the proper entry
            m = m2
        endif
        p => Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
        do i = 1, 4
            if (m2%l(i)%n /= 0) then
                array_rank = i
            endif
        enddo
        if (array_rank /= DIM) then
            nullify(p)
            if (present(m)) then
                m = GMM_NULL_METADATA
            endif
            Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
        else
            Cat(gmm_get,EXTENSION,) = GMM_OK
        endif
    endif
end function Cat(gmm_get,EXTENSION,)


subroutine Cat(gmm_dealloc_ptr,EXTENSION,)()
    use gmm_internals
    use Cat(pointer_table_data_,EXTENSION,)
    implicit none

    deallocate (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
    nullify    (Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p)
end subroutine Cat(gmm_dealloc_ptr,EXTENSION,)

#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH

integer function gmm_delete(iname)
    use gmm_internals
    implicit none
    character(len=*), intent(in) :: iname
    include 'gmm_directory_interface.inc'
    integer*8 :: key
    integer :: datatype

    key = 0
    call check_directory_entry(iname, key)
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! quick check using key was not successful
        call find_directory_entry(iname,key)
    endif
    if (cur_page .eq. 0 .or. cur_entry .eq. 0) then
        ! variable not found
        key= GMM_KEY_NOT_FOUND
        gmm_delete = GMM_VAR_NOT_FOUND
        return
    else
        datatype = directory(cur_page)%entry(cur_entry)%data_type
        directory(cur_page)%entry(cur_entry)%name = 'Variable deleted upon request'

        dtype: select case (datatype)
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
            case (EXTENSION)
            call Cat(gmm_dealloc_ptr, EXTENSION,)()
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
        end select dtype

        ! Invalid layout
        directory(cur_page)%entry(cur_entry)%l = GMM_NULL_LAYOUT
        ! Null attributes
        directory(cur_page)%entry(cur_entry)%a = GMM_NULL_ATTRIB

        gmm_delete = GMM_OK
        return
    endif
end function gmm_delete


#undef EXTENSION
#endif
#ifndef INTERFACEONLY
integer function gmm_getmeta2(iname, m)
#include "gmm_definitions.inc"
    ! name (partially redundant with attributes)
    character(len=*), intent(in) :: iname
    ! attributes (name in attributes is not used)
    type(gmm_metadata), intent(out) :: m
    integer gmm_getmeta
    external gmm_getmeta
    gmm_getmeta2 = gmm_getmeta(iname, m)
end function gmm_getmeta2
#endif
